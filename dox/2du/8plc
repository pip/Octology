#!/usr/bin/perl
# D6OMHm3L:8plc crE8d to read PipStuart's <Pip@CPAN.Org> 8.txt (mainly 2 specific columns) to tabul8 && print the 8 Precursor Letter Counts;
# 2du:Dtect nstd of hRdcOd 16th colm,add dur8z around sectnz&&mAB try2optimIz per4manc of slOSt pRtz(tkz about 12-18secs for basic to -all),
#   4 -g gM8ria:try2add sumz,productz,modez,meanz,medianz,cnsidr delta difz&&r8ioz,prIm factrz,add colrz,graph rangez,iconz,contMpl8 othr good posibl repz,
#     also try deltas with sub-colr 4grndz by magnitude gradu8ionz or syswIdfrEqz,
#   4 -g:try reloopng 4 Ech singl rOw alInmNtz nstd of init blox,fix all -p pg1f to count up to actual linz rather than hardcode 160x48 limitz,
#   mAB try more agrSiv minimIz8ion of gM8ria prImz whN l8r sufx or prEfx alreD in PLz,alsO try special rEordr of lRgSt prEfxz2trim dn rAng,
#   mk sepR8 tabul8ion of 8-words used in l8r document8ion wi not8ion 4thOs not yet included in top lists (thN optn2ignor easy conjug8ions && pre/suffixes),
#   mk easy optn4 fulc 2use 1colm 4grep,add 4m@d percNtz,stuD wc && mk a8:cnt8/8c wi fulc -f? && 8plc as -l? optnz(rEdo hedrtXt),colr letrz,add f0ntz4 8trm;
use strict;use warnings;use utf8;use v5.10;use Octology::a8;use Octology::b8;
my $d8VS='I3PMLETR';       my $clrf=1;my $fulf=0;my $argz='';$argz= join(' ',@ARGV) if(@ARGV);my $Stxt='';my $folf=0; # add 4-Or-Less-Flag
my $edVS=        '';       my $pg1f=0;   $pg1f=1 if($argz=~ /(^|\s)-?-?[^p]*p/i); # find -?p(age) flag2limit some extra long output to first 48-line page
my $mxws=        19;       my $lpsf=0;   $lpsf=1 if($argz=~ /(^|\s)-?-?[^l]*l/i); # find -?LetrPrecursShortsFlag  # if MaXWordSize evr grOz,wil nEd2incrEs|Dtct
my $clmz=        80;       my $gm8f=0;   $gm8f=1 if($argz=~ /(^|\s)-?-?[^g]*g/i); # find -?g(m8r) flag2count&&adorn wi math 4mUl8ions stRting wi 2letr
my $linz=        24;       my %fulc=();  $fulf=1 if($argz=~ /(^|\s)-?-?[^f]*f/i); # find -?f(ull) flag to count && sort all         characters at end
                           my @folc=();  $folf=1 if($argz=~ /(^|\s)-?-?[^w]*w/i); # find -?w(ord) flag to count && sort all maximum char-words at end
                           my %lpsd=();  $clrf=0 if($argz=~ /(^|\s)-?-?[^s]*s/i); # find -?s(SKp) flag arg4vim ':r!8plc s' 2B lIk ':r!8plc|sS'
$clmz=$ENV{'COLUMNS'} if(exists($ENV{'COLUMNS'})); # mAB also Dtect H varE8ionz
$linz=$ENV{'LINES'  } if(exists($ENV{'LINES'  }));my $lnmx=$linz - 2;my @jd8a;
if($argz=~ /(^|\s)-?-?[^a]*a/i){   $lpsf=$gm8f=$fulf=$folf=1;} # set All optional section flags at once
if($argz=~ /(^|\s)-?-?[^h]*h/i){$Stxt.=" $0 - 8.txt Precursor Letter Counter d8VS:$d8VS by $auth to gener8 Octology applic8ion name d8a analysis;
  h   - print this Help text and exit; below options are flags which can be combined in any order, but extra sections print in order of comput8ion;
  s   - print below options as just plain text (Strip default eScape color codes, like running `$0 | sS` post-process);
  p   - print below options as limited to just first $lnmx-line Page instead of default everything (fixed 160x50 single Pages work for -l -w -g);
  a   - print All extra options below (like calling `$0 lwgf`)   (with -p limiting almost all sections to just 1 160x50 Page of output for each);
  l   - print Letters of precursors sorted by size                 (with -p only printing up to z 102 and cutting off before c 131 as 1 Page);
  w   - print Words sorted by size up to current maximum of $mxws     (with -p only printing from 2 to  9 for just first $lnmx-line Page);
  g   - print gM8ria 'Gematria' word valU8ions in aligned sections as preliminary trial of a few short approaches to some numerology;
  f   - print Full character counts (maybe l8r extracted to a8:cnt8 and `8c` like `wc`);";
  if(20 < $clmz && $clmz < 160){my @htxt=split(/\n/,$Stxt);$Stxt='';my $lsiz;my $tokn;for(@htxt){$lsiz=0;while(s/^(\s*\S+)//){$tokn=$1; # smRt split Help tXt
        if($lsiz + length($tokn) > $clmz){$Stxt.="\n" . (' ' x 8);$lsiz=8;$tokn=~ s/^\s+//;} $Stxt.=$tokn;$lsiz+=length($tokn);} $Stxt.="\n";}}
  open my $out8,'>&',STDOUT or die "Can't open  duplic8 STDOUT handle: $!";binmode $out8,':encoding(UTF-8)';print $out8 $Stxt; # crE8 local duplic8 of global
  close   $out8             or die "Can't close duplic8 STDOUT handle: $!";exit();}
my $efyl ='8.txt';my @lcnt;$lcnt[$_]=0 for(0..b10('z'));my @acnt;$acnt[$_]=0 for(0..b10('z'));my $done=0;my $t0tl=0;my $text;my $actx;my $sclc;my $gttl=0;
unless(-r         "$efyl"){$efyl=$ENV{'HOME'} . "/dox/2du/$efyl" if(exists($ENV{'HOME'}));} # try2add likely path when file not in local dir
open(my $eflh,'<',"$efyl") or die "!*EROR*! Couldn't open eight-file to read counts! $!";binmode $eflh,':encoding(UTF-8)';
while( <$eflh>){my $ldat=$_;$done=1 if(/^$/); # sets done to true when first blank line encountered
  if(/^#.*?\$d8VS\s*=\s*(['"])([0-9A-Za-z._]{8})\1\s*;/){$edVS=$2;} # this match regex seems to still need \1 && presumably ${1} would work in s/// replacement
  if  (!$done &&  $ldat  !~ /^\s*#/){ # the header lines (&& potentially l8r blocks) have pound as first non-whitespace character design8ing comments to skip
    if     (length($ldat) >= 16  ){my $pltr; # 16th column is l8st dflt 8 loc8ion, but some l8r could slide furthr
      if   (substr($ldat,    16,1) eq '8'){$pltr=substr($ldat,15,1);} # hard-coding columns as aligned interest (used to be 14 && 13, now 16 && 15)
      elsif(       $ldat =~   /^.*?(\w)8/){$pltr=$1;} # for a few lines with particularly long 8 names, the 8 wouldn't fit in the same column so srch for 1st 8
      if   (       $ldat =~   /^\s*(\w{0,15}8\w*)(\s|:)/i &&  ($folf || $gm8f || $lpsf)){my $ewrd=$1; # if mAB FindOrdrdLsFlag,thN lOdup Cntz arAy of subhashes
        push(@{$lpsd{$pltr}[        length($ewrd)]}, $ewrd) if($folf || $gm8f || $lpsf); # bild LetterPrecursorShortestsD8a for -l
        for my $wsiz (2..$mxws){if( length($ewrd) == $wsiz){$folc[$wsiz]{$ewrd}++;
            print "$G!*EROR*! duplic8 of wsiz:$wsiz for ewrd:$ewrd to remove l8r;\n"    if($folc[$wsiz]{$ewrd} > 1);}}} # sneak in Xtra duplic8ion error check
      $lcnt[b10(   $pltr )]++   if(defined($pltr) );}} # wrapng $pltr in lc() B4 b10() showz just 23(/34) countz in rvrs ordr: rnlc tzeg mdvp usbx fwkh iyo
      $text .=     $ldat;       if($fulf){my @chrz= split(//,$ldat);for my $char (@chrz){$fulc{$char}++;}}} # &&!lc: rnlc tzEm gpdv usbN LDCV URxf Gwkh PMIy SO
my    $letz  =join('',keys(%lpsd)); # these PLz won't be in order, but should be good enough for regex char-classes
close($eflh)               or die "!*EROR*! Couldn't close eight-file after reading! $!";
#if($fulf){%fulc=();for(split(//,'the of and to a in is I that it for you was with on as have but be they')){$fulc{$_}=0 if(!exists($fulc{$_}));$fulc{$_}++;}}
# temporarily try to hijack fullcharcounts above to just look within top 20 English words to compare; should extract ccnt to be like this && wc wi vary columnz
# results: Idrv:1, bfuwy:2, ns:3, ei:4, oh:5, a:6, t:8, ' ':19; # "I drive by your freeway and say 'oh a tea Space!'"
while($text=~ s/(\w)8//){$acnt[b10($1)]++;}   # counts chopping out all PLs && 8s
my @scnt = sort { $a <=> $b } (@lcnt);
for(my $sndx=$#scnt;$sndx >= 0;$sndx--){ # 2du:append bar-graphs of respective count values;
  if(($sndx > 0 && $scnt[$sndx] == $scnt[$sndx - 1]) || ($sndx == 0 && $scnt[0] == 0)){splice(@scnt,$sndx,1);}} # below2 sepR8 prnt blox for not color or with
$Stxt.=                                            sprintf("${C}8${M}Pre-cursor${Y}Letter${R}Counter$W:$G d8VS$C=%s$G\n",            d8c($d8VS));
my $efsz = length($efyl);$Stxt.=                   sprintf("$O  efyl$C=%s".' 'x (18-$efsz).$G.          " edVS$C=%s$G\n",c8fn($efyl),d8c($edVS));
$Stxt.=                                            sprintf "${C}8${M}Pre${Y}Letr$R Ct$C Full${W}Document${R}Counts\n";
$Stxt.=                                            sprintf   "$B-------- -- ------------------\n";
for(@scnt){                                                                                        $sclc=0;$actx ='';
  for my $lndx (0..$#lcnt){
    if(defined($lcnt[$lndx]) && $lcnt[$lndx] == $_){$Stxt.=   $Y           . b64($lndx) ;$t0tl+=$_;$sclc++;$actx.=' '.b8c(sprintf("%2s",b64($acnt[$lndx])));
                                                                                         $gttl+=$acnt[$lndx];}}
  my $spad=21 - 3*$sclc;$spad=0 if($spad < 0);$actx.=' ' x $spad;my $blsz=41;my $r8io=$blsz/64.0; # prEpad Nd of acnt ndxz B4 sclc flipz 4 stRtng letr colm
  $sclc   = 9 -   $sclc;$sclc=0 if($sclc < 0); # exploring gener8ing additional new bar-graphs of b8 Counts across remaining line width
  if($clmz >= 160){my  $ddig =$_   ;$actx.=' ' x (126-int($_*$r8io)); # (96-int($_/2)) wi spad=50-3*sclc abov,thN (114-int($_*$r8io)) wi spad=32-3*sclc
    while($ddig >= 64){$ddig-=   64;$actx.= $o . ('#' x  ($blsz- 1)) . "$R@";} my $mdig=$ddig % 2; # try2mk Orange 2nd blox Nd in last Red boundry
                       $ddig*=$r8io;$actx.= $R . ('#' x   $ddig    ); # odd mod rEmAndr BlO reprEsNtd betr whN Ech 64 blok fitXactly32chrz,sO just4 sOlO 1now
    if($mdig && ($blsz==32||$_==1)){$actx.= $R .  '1'               ;}} # outr colm widt tSt shud only draw bRz 4 wId termz now
  $Stxt.=sprintf ' '  x $sclc; $Stxt.=             sprintf(  "%s $actx\n",b8c(sprintf("%2s",b64($_))));}
                                                                                   my $ct0t=$G . cma($t0tl);$ct0t=~ s/(,)/$Y$1$G/g; # pre-colr comma'd t0tal
$Stxt.=                                            sprintf   "$B-------- -- ---\n";my $cttl=$M . cma($gttl);$cttl=~ s/(,)/$Y$1$M/g; # pre-colr comma'd total
$Stxt.=                                            sprintf("${C}t${M}0${C}tlz    %s %s$W :  $B(${R}b10$B)  %s  %s$W;$z",
                                                    b8colr(sprintf("%2s",b64($t0tl))),b8colr(sprintf("%2s",b64($gttl))),$ct0t,$cttl);
if($lpsf){$Stxt.="\n${W}All${R}Counts${o}Not${M}Matching${C}Words${B}List$G -$K likely from just d8-stamps, pal8 codes, or other non-word strings with 8";
  my $ptot=0;my @acor;my $slin= '';$Stxt.=" (ordered by freq then letr)$W:\n"; # PrevrowTOTalwidth, AllCountsORdered, SortedLINe
  for(0..63){if(defined($acnt[$_]) && $acnt[$_] && !exists($lpsd{b64($_)})){$slin.="$C ".b64($_)."$W:";$slin.=$r;$slin.=$R if($acnt[$_]>2);$slin.=$acnt[$_];
      push(@{$acor[$acnt[$_]]},b64($_));}}
  for(0..63){if(defined($acor[$_]) && $acor[$_]){$Stxt.=" $R";$Stxt.=$r if($_ <= 2);$Stxt.=b64($_) . "$W:$C" . join('',@{$acor[$_]});}} $Stxt.="\n$slin";
  $Stxt        .="\n${Y}Letter${M}Pre-cursor${C}Shortests${B}List$G -$K shows all entries by$M P${Y}L$K with growing word-sizes$W:\n\n";for(@scnt){
    last if($_ >= 108 && $pg1f); # for single -p page try to skip out after t && z 102 before c && l && n 131
    for     my $lndx (0..$#lcnt){if(defined($lcnt[$lndx]) && $_ ==   $lcnt[    $lndx]){my $letr=b64($lndx);
        my                                                                 $rtot=2 ;   my $ltot=     0    ;$Stxt.="$Y$letr$R:"; # hRdcOded prEnwlInz abov
        for my $wsiz (2..$mxws ){if(exists ($lpsd{$letr}) && defined($lpsd{$letr}       ) && scalar(@{$lpsd{$letr}       }) &&
                                                             defined($lpsd{$letr}[$wsiz]) && scalar(@{$lpsd{$letr}[$wsiz]})){
            if    ($rtot + length($wsiz                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
            $rtot        +=length($wsiz                     ) + 1          ;$ltot+=          scalar(@{$lpsd{$letr}[$wsiz]});$Stxt.="$B$wsiz$W:$z";
            for my $wndx (0 .. $#{$lpsd{$letr}[$wsiz]}){
              if  ($rtot + length($lpsd{$letr}[$wsiz][$wndx]) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
              $rtot      +=length($lpsd{$letr}[$wsiz][$wndx]) + 1 ;  $lpsd{$letr}[$wsiz][$wndx]=~ s/(8)(ion)$/$1$C$2$z/;     # colr most comon ion sufx
                                                                     $lpsd{$letr}[$wsiz][$wndx]=~ s/($letr)(8)/$o$1$G$2$z/g; # colr 8PLz
              $Stxt      .=       $lpsd{$letr}[$wsiz][$wndx]  .' ';}}}
        if        ($rtot + length($ltot                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
        $rtot            +=length($ltot                     ) + 1 ;                      $Stxt.=  "$M$ltot ";
        if($ptot + $rtot <= $clmz){$Stxt=~ s/(.*)\n/$1/s;$ptot+=$rtot;}else{$ptot=$rtot;}$Stxt.="\n";$rtot=0;}}}} $Stxt=~ s/\n$//;
if($folf){$Stxt.="\n${Y}Word${R}Sort${C}By${B}Size$G -$K up to current maximum$M $mxws$K or one$p page$K if given$p -p$W:\n";my $maxs=$mxws;$maxs= 9 if($pg1f);
  for   my $wsiz (2..$maxs ){my @folk=sort(keys(%{$folc[$wsiz]}));$Stxt.= $B.sprintf("%${wsiz}d ",scalar(@folk));my $rtot=$wsiz+1;
                                                                  $Stxt.="$R $wsiz"        unless(scalar(@folk));
    for my $fndx (0..$#folk){my $foln=$folk[$fndx];if($rtot + length($foln) + 1 >  $clmz){$Stxt.="\n";$rtot=0  ;} $rtot+=length($foln)+1;
                                $foln=~ s/(8)(ion)$/$1$C$2/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;$Stxt.="$z$foln ";} $Stxt=~ s/ $/\n/;}} # $Stxt.="$G @folk\n";
# I47M1b96:just l8st 2z 3z 4z,nEd2cut ? 2fit nXt `sumb 2` 96 pAg,b8 c8 d8 g8 w8 ckm8 pal8 upd8 alredy bin is 8,DlA sumb4 N8 DN8 NfN8 SSN8 as obtuse:
#  9   f8   h8   k8   l8   m8   p8   r8   s8   y8  # 9+35=44,nEd 40 of 73 4z (isol8ing 33 worst for l8r) to accept l8st 12 over in bin to complete next 96
# 35  aV8  ab8  ag8  al8  aw8  b8a  bl8  cS8  cr8  el8  f8h  f8l  fL8  fr8  gM8 gr8 iD8 ir8 mL8 n8l oP8 or8 pN8 pl8 pr8 rN8 sN8 sk8 sl8 sp8 st8 sw8 tr8 ur8 vL8
# 73 abl8 aer8 agn8 ans8 aur8 bel8 ber8 bin8 bor8 bov8 col8 crE8 crN8 cur8 deV8 deb8 dil8 don8 elu8 equ8 est8 exP8 fix8 gyr8 ing8 inm8 inn8 ion8 jub8 jug8 kin8
#    l8nt lan8 leg8 lig8 loc8 lor8 lun8 lux8 lyr8 lys8 mal8 meD8 mec8 met8 mic8 mor8 mut8 neg8 not8 nov8 obV8 obl8 orn8 phN8 pir8 pup8 r8io raD8 reb8 rel8 rot8
#    rug8 s8E8 sav8 sed8 soC8 stL8 str8 tan8 unE8 vac8 zon8. 3rd page sumb could be last 33 4z then nXt bSt 63 of 118 5z (leaving 55, with near half for l8r);
if($gm8f){$Stxt.="${W}Gener8 gM8ria primes for names by$B 3$W segments (${Y}PreLetters$W,$G Suffixes$W,$C Prefixes$W)...\n$G"; my $eqfz='';my $eqct=0;
  my %w2pm;my %wh2p;my @wpls;my %kvs8;my %pl8z;my %sufz;my %prez;my %pl8s;my %sufs;my %pres;my %allc;my %allp;my @plrl;my %ppbs;my $bbct=0;my $colc=0;
  my $mxpa=1;#$mxws=19;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){$pl8z{$2 }=0 unless(exists($pl8z{$2 }));$pl8z{$2 }++;
        if(defined($1) && length($1)     ){$prez{$1 }=0 unless(exists($prez{$1 }));$prez{$1 }++;}
        if(defined($3) && length($3)     ){$sufz{$3 }=0 unless(exists($sufz{$3 }));$sufz{$3 }++;}
        else                              {$sufz{'_'}=0 unless(exists($sufz{'_'}));$sufz{'_'}++;}}}}
  for   my $kyst (sort(keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){$Stxt.=sprintf("${Y}plct$W:%s$M%4d$Y pl8z$W:$o%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++)                             ;}} %kvs8=();#$Stxt.="\n";
  for   my $kyst (sort(keys(%sufz))){push(@{$kvs8{$sufz{$kyst}}},$kyst);} # nice that there are exactly 8 count categories of sufz, 14 PLz, 6 prez (28 totl)
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){if(@{$kvs8{$kvct}} == 1 && $kvs8{$kvct}[0] eq  'ion'){
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:${B}ion\n",b8c(sprintf("%3s",b64($kvct))),$kvct);}else{
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));}
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}} %kvs8=();#$Stxt.="\n"; # try to reuse earlier segments
  for   my $kyst (sort(keys(%prez))){push(@{$kvs8{$prez{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){my $s8ls='';my $rtot=18; # bild up an rtot to pump newlinez into s8ls before appending wider than clmz
    for my $ssvl (sort(@{$kvs8{$kvct}})){if($rtot + length($ssvl) + 1 >= $clmz){$s8ls.="\n";$rtot=0;} $rtot+=length($ssvl) + 1;
      $s8ls.=S(substr('YCMGRBop',b10(substr($ssvl,0,1)) % 8,1)) . "$ssvl ";} $s8ls=~ s/ $//;
    $Stxt.=sprintf("${C}prct$W:%s$M%4d$C prez$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,$s8ls);
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}}                # try to keep reusing earlier segments
  $Stxt  .="${W}gM8ria primes with$B 3$W sepR8 sections:$Y PL$W,$G suffixes$W,$C prefixes$W but with special case 1st$G suffixes$W:$z _$W &&$B ion$W for ";
  $Stxt  .="smaller highest nums...\n";
  %pl8s=();%sufs=();%pres=();%w2pm=();%wh2p=();%kvs8=();@wpls=();%allc=();%allp=();$bbct=$colc=0;$mxpa=1;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        push(@{$ppbs{$pltr}},$pfix) if(length($pfix));}}}
  for   my $kyst (sort(            keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}          $allp{prim($mxpa)}='_'  ;$sufs{'_'  }=prim($mxpa++);
                                                                                               $allp{prim($mxpa)}='ion';$sufs{'ion'}=prim($mxpa++);
  for   my $kvct (sort {$b <=> $a} keys(%kvs8) ){for my $sprt  ( sort(@{$kvs8{$kvct}})       ){$allp{prim($mxpa)}=$sprt;$pl8s{$sprt}=prim($mxpa++);
                                                                                                                unshift(@plrl,$sprt)              ; }}
 #for   my $pdig (0..3                         ){                                              $allp{prim($mxpa++)}="$pdig";} # pad4digitz2grow curNt stably?
  for   my $kyst (sort {length($a) <=> length($b)} sort(keys(%sufz))){if($kyst !~ /^(_|ion)$/){$allp{prim($mxpa)}=$kyst;$sufs{$kyst}=prim($mxpa++); }}
 #for   my $pdig (4..7                         ){                                              $allp{prim($mxpa++)}="$pdig";} # digz wil nEd2ch if evrin spLng
  for   my $pltr (      @plrl                  ){for my $sprt  (      @{$ppbs{$pltr}}        ){unless(           exists($pres{$sprt})){ # rvrs much worse 270M
                                                                                               $allp{prim($mxpa)}=$sprt;$pres{$sprt}=prim($mxpa++);}}}
  $Stxt  .="${z}pres${C}By${B}Size$W:$z";my $rtot=11;for my $sprt (sort {length($a) <=> length($b)} sort(keys(%pres))){
    if($rtot + length($sprt) + 1 >= $clmz){ $Stxt.="\n";$rtot=0;}
    $rtot    +=length($sprt) + 1;           $Stxt.= S(substr('YCMGRBop', length($sprt) % 8,1)) . "$sprt ";} # colr sequ by size
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        my $cmps=$pl8s{$pltr};$cmps*=$sufs{$sfix}   if($sfix ne '_' || $pfix);$cmps*=$pres{$pfix} if($pfix);$wh2p{$cmps}=$curw;$w2pm{$curw}=$cmps;
        $bbct++ if(length(b64($cmps)) >  length($curw)); # count b64 versions of composite numbers that are longer than (or same as) 8-word they refer to
       #$Stxt.=sprintf("$z%19s%s$C%2d",$curw,b8c(sprintf("%5s",b64($cmps))),$bbct);if(++$colc==6){$colc=0;$Stxt.="\n";}
      }}} $colc=0;$eqct=0;$eqfz='';$Stxt=~ s/\n?$/\n/; # now 0/1238 have longer b64 numrep than referred 8word
  for   my $kyct (sort {$a <=> $b} keys(%wh2p)){my $vwrd=sprintf("%20s",$wh2p{$kyct});for my $nndx (1..4){if(substr($vwrd,-1*$nndx,1) eq '8'){my $sfsz=5-$nndx;
        $vwrd=~ s/^(\s{$sfsz})(.+)$/$2$1/;last;}} # right-align the 8 column for almost all words (except when suffix is longer than 4 chars)
    $vwrd    =~ s/^(\s*dil88ion\s*)(\s)$/$2$1/;   # special-case alignment correction to 1 extra space for '88ion'
    $vwrd    =~ s/([A-Z])(8)/$Y$1$G$2$z/gi;my $tkct=$kyct;my $twrd='';my $tpmz='';my $sfxf=0;for my $tprm (sort {$a <=> $b} keys(%allp)){
      if   (($tkct % $tprm) == 0              ){$tpmz.="$tprm,";$tkct/=$tprm;  # mA nEd2filtr out 0..7 pad digitz,thN add special sufx ckz4 _|ion 1st, ...
        if   (length($twrd) == 0              ){                               #   ...thN get reqd PL,thN mAB othr sufx,fInalE prEpNd any rEmAning prefix
          if ( $allp{$tprm} =~ /^(_|ion)$/    ){$twrd = $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
          else                                 {$twrd ="$allp{$tprm}8"     ;}} # stil quite simpl3sections always in ordr (Xcept special _|ion sufxz)
        elsif(length($twrd) == 2 && $sfxf == 0){$twrd.= $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
        elsif($twrd =~ /^(ion)$/ && $sfxf == 1){$twrd ="$allp{$tprm}8$twrd";}  # 27,676,799 ostent8ious last (wi 8 pad digitz,4btwn sectnz 4 mor stabl growth)
        else                                   {$twrd ="$allp{$tprm}$twrd" ;}}}# 25,308,869 ostent8ious last (after some additions && removing 8digit padding)
    $tpmz=~ s/,$//;my $trmc='!';if($wh2p{$kyct} eq $twrd){$trmc=';';$eqct++;}else{$eqfz.="$G$wh2p{$kyct}$W:$B$twrd$W, ";} $vwrd=~ s/(ion\s*)$/$B$1/; # tryBlu
    if($pg1f){last if($kyct> 103754);$Stxt.=sprintf("%s$z%s$W%s",b8c(sprintf("%4s",b64($kyct))),$vwrd,$trmc);if(++$colc == 6){$colc=0;$Stxt.="\n";}}
    else     {    $Stxt.=sprintf("$M%11s %s$z %s$W%s",cma($kyct),b8c(sprintf("%5s",b64($kyct))),$vwrd,$trmc);if(++$colc == 4){$colc=0;$Stxt.="\n";}}
  } $eqfz=~ s/, $//;  $Stxt=~ s/\n?$/$W\n/;$colc=0;#Stxt.="eqct:$eqct totl:" . scalar(keys(%wh2p)) . " eqfz:$eqfz"; # rebild Cmz2alreDB fIn4 100% of cur8wrdz
  open my $log8,'>',"$ENV{'HOME'}/.log/8pc.ls" or die "Can't open  log 8PrimesComponents.LiSt file handle: $!";binmode $log8,':encoding(UTF-8)';
  print   $log8 "# $d8VS:~/.log/8pc.ls gener8d by 8plc with 8.txt edVS:$edVS to save sepR8 reference to 8-word prime maps by PipStuart <Pip\@CPAN.Org>;\n";
  for  my $prmk (sort {$a <=> $b} keys(%allp)){print $log8 sprintf(" %3s %-14s",b64($prmk),$allp{$prmk});if(++$colc == 8){$colc=0;print $log8 "\n";}}
  close   $log8                                or die "Can't close log 8PrimesComponents.LiSt file handle: $!"; # try2wrItout prImz list for l8r sepR8 rFrNc
          delete($folc[2]{ 'N8'});delete($folc[2]{  'b8'});delete($folc[2]{  'c8'});delete($folc[2]{  'd8'});delete($folc[2]{  'g8'});delete($folc[2]{  'w8'});
          delete($folc[3]{'DN8'});delete($folc[4]{'NfN8'});delete($folc[4]{'SSN8'});delete($folc[4]{'ckm8'});delete($folc[4]{'pal8'});delete($folc[4]{'upd8'});
          delete($folc[5]{'m8rix'});delete($folc[5]{'coll8'}); # not sure if coll8 is best 2nd to remove of 5z, but m8rix is probably good enough as p8:m8rx
 #$Stxt  .="${W}gM8ria primes with altern8ing sections of next most prevalent remaining character (when any next none-left indic8or on one side drops):\n";
  # so maybe figure out best new structures && altern8 composite ordered escal8ing prime approach allowing for next component to be most popular long string
  my   @alpn;my %pctz;my %sctz;my @pfxz;my @sfxz;my $done=0;my $pfxf=0;my $sfxf=0;$colc=0;$mxpa=1;#%pl8s=();%sufs=();%pres=();%w2pm;%wh2p%kvs8@wpls%allc$bbct
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # maybe this attempt will be quite similar to a trie retrieval graph on next letters?
    for my $fndx (0..$#folk){my $curw=$folk[$fndx]; # nEd2justkEp loopng thru all primes next altrn8ng acceptance && rEplAyng
      if($curw=~ /^(\w*?([A-Z]))8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1)&& length($1));
        push(@pfxz,$pfix) if(length($pfix));     # preletrs remaining should just prepend reverse prefixes so wrapped $1 above around $2 to just ignore pltr
        push(@sfxz,$sfix) if(length($sfix));}}}  # need new or reuse flagz for all suffixes or prefixes completely termin8ing for just remainder of opposite
  while(!$done){%pctz=();%sctz=();$pfxf=$sfxf=0; # maybe initial flagging for done && side termin8ors && can build up all biggest nexts
    # maybe rethink a bit && just push all pfix && sfix to @?fxz for p s PipStuart PreSuffix PlainSwamp to just reloop apart right around 4 nxt bst cnt
    # while altern8ing consumption, might track pending termin8 suffix processing as like a competing string for sided st8us popularity becomes priority...
    #   but still may mainly be left with a really long tail of tons of single jumbled characters, or maybe require higher aggreg8ion prior to prime alloc8
#   if   (scalar(@alpn) % 2 &&   !$pfxf){$pctz{substr($pfix,-1,1)}++;} # probably can't just modulo 2 since also must flag pre or suf already finished too
#   elsif($sfix             eq  '_'    ){$sctz{       $sfix      }++;} # kinda abandoning ship on this method of too many small top single-char strings
#   elsif($sfix             =~  /^(\w)/){$sctz{       $1         }++;} # theoretically might be able to cmp max next solo char vs. top pairs * 2 broaden size
#   else                                {$sctz{        '.'       }++;} # maybe try adding '.' dot all suffix completed by that point
    $done=1; } # set @alpn= sided strings in prime alloc8 order for prim($mxpa++) = nxt alloc8ionz && $done=1 when none left
  # want to start right _ 880 empty suffixes but then may want to postpone alloc8ing another maybe . dot code for termin8ing past all popu suffix nexts
  # pretty complex to keep counting up exclusively the highest current stage then to adopt && recompute from only remainders after earlier selections
  # actually maybe closing suffixes after just running all next best single letters;  @plrl should have PreLetrsRvrsList, but need combining counts l8r;
# open my $log8,'>',"$ENV{'HOME'}/.log/8ps.ls" or die "Can't open  log 8PrimesSidestring.LiSt file handle: $!";binmode $log8,':encoding(UTF-8)';
# print   $log8 "# $d8VS:~/.log/8ps.ls gener8d by 8plc with 8.txt edVS:$edVS to save sepR8 reference to 8-word prime maps by PipStuart <Pip\@CPAN.Org>;\n";
# for  my $prmk (sort {$a <=> $b} keys(%alpn)){print $log8 sprintf("%-4d %-15s ",$prmk,$alpn{$prmk});if(++$colc == 7){$colc=0;print $log8 "\n";}}
# close   $log8                                or die "Can't close log 8PrimesSidestring.LiSt file handle: $!"; # try2wrItout prImz list for l8r sepR8 rFrNc
  my %jmap=('c'=>0,'z'=>1,'l'=>2,'t'=>3,'n'=>4,'E'=>5,'r'=>6,'g'=>7,'_'=>8);my @jmls=(split(//,'czltnErg_')); # cycl joystk dirs from down clockwise around
  my $bwid=52;my @sepm=(''); # it looks like the largest 9 PreLetters fit almost all their members, probably getting close to 68% of all 8-words in 8 blox
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1)&& length($1));
        my $sfcl=$B;$sfcl=$C if($sfix ne 'ion'); # Wow! echoing all 8 blox && piping thru `wc -w` yielded exactly 888 =)
        if($pltr eq 'm'){ # try to load sepR8d special m d8a to shoehorn in below g in the lower right 7 blok
          if(length( "$pfix$sfix " . sS($sepm[-1])) > $bwid){push(@sepm,'');}
          $sepm[-1].="$z$pfix$sfcl$sfix " if($#sepm <  16 && length("$pfix$sfix") && length("$pfix$sfix " . sS($sepm[-1])) <= $bwid);}
        if(exists($jmap{$pltr})){$jd8a[$jmap{$pltr}]=[''] unless(defined($jd8a[$jmap{$pltr}]));
          if($#{$jd8a[$jmap{$pltr}]} <  16){my $jrnd=$#{$jd8a[$jmap{$pltr}]}; # try2bild 8chr blox of $bwid proly 53 or a bit less colmz by 16 rowz each belo
            $jd8a[$jmap{$pltr}][$jrnd] ='' unless(defined($jd8a[$jmap{$pltr}][$jrnd]));
            if(length("$pfix$sfix " . sS($jd8a[$jmap{$pltr}][$jrnd])) > $bwid && @{$jd8a[$jmap{$pltr}]} <  16){$jd8a[$jmap{$pltr}][++$jrnd] ='';}
            $jd8a[$jmap{$pltr}][$jrnd].="$z$pfix$sfcl$sfix " if($jrnd <  16 && length("$pfix$sfix") && # hopefully won't space ahead for l8, r8, g8, etc.
                                                                               length("$pfix$sfix " . sS($jd8a[$jmap{$pltr}][$jrnd])) <= $bwid);}}}}}
  for   my $rndx (0..15){
    for my $jbnd (3.. 5){
      if($#{$jd8a[$jmap{$jmls[$jbnd]}]} >= $rndx              ){my $rosl=$bwid - length(sS($jd8a[$jmap{$jmls[$jbnd]}][$rndx]));$rosl=0 if($rosl < 0);
        $Stxt.=$jd8a[$jmap{$jmls[$jbnd]}][$rndx] . ' ' x $rosl;}else{$Stxt.=' 'x $bwid;}} $Stxt.="\n";}
  for   my $rndx (0..15){
    for my $jbnd (2,8,6){
      if($#{$jd8a[$jmap{$jmls[$jbnd]}]} >= $rndx && $jbnd != 8){my $rosl=$bwid - length(sS($jd8a[$jmap{$jmls[$jbnd]}][$rndx]));$rosl=0 if($rosl < 0);
        $Stxt.=$jd8a[$jmap{$jmls[$jbnd]}][$rndx] . ' ' x $rosl;}else{$Stxt.=' 'x $bwid;if($jbnd == 8){my $hbwd=int($bwid/2)+4;my $stal=' ' x ($hbwd-5);
          if   ($rndx == 7){$Stxt=~ s/\s{$hbwd}$/$Y$jmls[3] $jmls[4] $jmls[5]$stal/;}
          elsif($rndx == 8){$Stxt=~ s/\s{$hbwd}$/$Y$jmls[2]   $jmls[6]$stal/;}
          elsif($rndx == 9){$Stxt=~ s/\s{$hbwd}$/$Y$jmls[1] $jmls[0] $jmls[7]$stal/;}
          elsif($rndx ==10){$Stxt=~ s/\s{$hbwd}$/$Y    m$stal/;}}                      }} $Stxt.="\n";}
  for   my $rndx (0..15){
    for my $jbnd (1,0,7){
      if($#{$jd8a[$jmap{$jmls[$jbnd]}]} >= $rndx              ){my $rosl=$bwid - length(sS($jd8a[$jmap{$jmls[$jbnd]}][$rndx]));$rosl=0 if($rosl < 0);
        $Stxt.=$jd8a[$jmap{$jmls[$jbnd]}][$rndx] . ' ' x $rosl;}else{ # try to squeeze "m" in the lower half of blok 7 lowr rite belo "g" in top half
        if($rndx >= 8 && defined($sepm[$rndx - 8])){$Stxt.=$sepm[$rndx - 8];}else{$Stxt.=' 'x $bwid;}
                                                                                       }} $Stxt.="\n";}
  # maybe since most prefixes are longer also altern8 inward from both ends preferring more total chars culled for wider from top 8 solos or some thresh?
  # ..or actually resummarize all above thoughts to 1st prime 2 given to suffix outside-in R2L for ion then 2nd 3 given to permanently termin8 any further
  #   attempts to altern8 for now known complete suffix for almost 94% of all words, then try biggest in L2R altern8 out for prefixes until all accounted
  # findng Specialy EficiNt permut8ions sEms daunting2preserve so much progress st8 for just multiple size strings before even delving to next or ultim8 best
  # ..&& by metrics of max composite plus some accounting for average offered too? think of betr d8astructz4sizng matching blockz && fix Pre/Suf Out/In ordr.
  # maybe when working, can lead to varE8ion for encoding most typical syllable pronunC8ion references then visual multiple assoC8ions && explore clustering;
  $mxws=  5 if($pg1f); # then mv 8p.ls 8pc.ls && start new 8ps.ls for Octology8 Prime Components or Side Strings (with _ empty right start 1st as 881 2z again)
  $Stxt=~ s/\n?$/\n/;for my $wsiz (2..$mxws){my @folk=sort(keys(%{$folc[$wsiz]}));my @fola=();$Stxt.=$G; # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    my $stcz=int($clmz / 6); # normal initial alignments are 5 characters plus space, which should normally fit original 26 word columns within 160 char colmz
    if($wsiz == 2){$Stxt.="${W}Only 2z fit with preceding lines of b8 (2 4095), products only also fit 3z, otherz should fit sums && averages (B4nw2ad).\n$B";
      for my $fndx (0..$#folk){my $b10w=b10($folk[$fndx]);$Stxt.=sprintf(" %5d"      ,$b10w);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$M";
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$C";}
    if($wsiz == 3){                                                                                                                  $Stxt.=   $M ;
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n"  ;}
    if($wsiz <= 5){                                                                                                                  $Stxt.=   $C ;
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %5d"        ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $fstr =sprintf(" %2.2f"      ,$fola[$fndx]);$fstr=~ s/(\.?0+)$/$r$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%5s" ,b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz aligned with other numb repz
                                                                              $Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.="$z ".' ' x (5 - length($folk[$fndx]));my $slbv;for my $nxtc (split(//,$folk[$fndx])){if($nxtc=~ /^[0-9A-Z._]$/i){
            if(defined($slbv)){if($slbv > b10($nxtc)){$Stxt.=$z.$B;}else{$Stxt.=S('Mb');} $Stxt.=b64(abs($slbv - b10($nxtc)));$slbv=b10($nxtc);} # EchUniq2!
            else              {   $slbv = b10($nxtc); $Stxt.=$z.$nxtc;}}}   $Stxt.="$z\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z"; # shOz dLtaz off prEv b64
      for my $fndx (0..$#folk){my $foln =sprintf(" %5s"        ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g; # valid PLz
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n";}
    elsif(scalar(@folk)){      my $wrdw=int($clmz / ($wsiz+1) );$Stxt.=$C; # skip over empty 18z
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %${wsiz}s"  ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $frsz =$wsiz-3; # mAB special cAs 8 2fit just %2.3f or mk trail zer0z dRk red nstd?
                               my $fstr =sprintf(" %2.${frsz}f",$fola[$fndx]);$fstr=~ s/(\.?0+)$/$k$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%${wsiz}s",b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz
                                                                              $Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){$Stxt.="$z ".' ' x ($wsiz - length($folk[$fndx]));my $slbv;for my $nxtc (split(//,$folk[$fndx])){if($nxtc=~ /^[0-9A-Z._]$/i){
            if(defined($slbv)){if($slbv > b10($nxtc)){$Stxt.=$z.$B;}else{$Stxt.=S('Mb');} $Stxt.=b64(abs($slbv - b10($nxtc)));$slbv=b10($nxtc);}
            else              {   $slbv = b10($nxtc); $Stxt.=$z.$nxtc;}}}   $Stxt.="$z\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){my $foln =sprintf(" %${wsiz}s"  ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n";}
# try2loop avrgz abov nstd but mA nEd special wrapz dn from 26 B4 6 to 6:22, 7:20, 8:17, ... shud B formUla or Dtectabl
# old notez4wsiz 2: this is probably more useful mean average summariez && think of prime factorz or othr wayz to represent mostly unique partz
#                5: try to cut 2 (or 6 if adding 4 N8 varE8ionz bakin) to get 5z dn2 3rd rel8ively clean concise set of 96 to make another sumb page out of
  } $Stxt.="${C}cuts$W:$Y 2$W:${G}N8 $o(${K}b8 c8 d8 g8 w8$o)$Y  3$W:${G}DN8$Y  4$W:${G}NfN8 SSN8 $o(${K}ckm8 pal8 upd8$o)$Y  5$W:${G}m8rix coll8$Y";
    $Stxt.="$Y  6$W:${G}?$Y  7$W:${G}?$Y ...\n"; # hopefully above -g will align a b10 line over b64 lines
  # try new small set of sequential prime number alloc8ions && then multiply recurring subset primes then try to refactor && reconstruct from gr8st down
  # I3QMIGHT:now 128 (2=>9,3=>34,4=>85) entries left after above cuts,but may want to splice more drastically down 32 more to top 96ish for next bin sumb page;
  $folc[2]{ 'N8'}=$folc[2]{  'b8'}=$folc[2]{  'c8'}=$folc[2]{  'd8'}=$folc[2]{  'g8'}=$folc[2]{  'w8'}=1;
  $folc[3]{'DN8'}=$folc[4]{'NfN8'}=$folc[4]{'SSN8'}=$folc[4]{'ckm8'}=$folc[4]{'pal8'}=$folc[4]{'upd8'}=1;
  $folc[5]{'m8rix'}=$folc[5]{'coll8'}=1; # need to try to put cuts back in so PL counts can match again
}   # maybe multiplying && factoring primes as essentially bit-flags requiring escal8ing order to build words to according to growing wsiz ordr is inefficient
    #   && still indirect, but mAB less useful than srchng whole word-set entirely to build all at once deliber8ly right-to-left wi prioritized substringz?
if($fulf){$Stxt=~ s/\n?$/\n/;my %cvlz=reverse(%fulc);my @ccnt= sort { $a <=> $b } keys(%cvlz);my $jus8=0;my $sumn=0; # 2colmzof fulcntz fitznIc undr50lInz sOfR
  for     my $cndx (0..$#ccnt){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    for   my $char (sort(keys(%fulc))){ # this now is intended to be just a single linear column which duplic8z the content of the orig 2-columnz below
      if    ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
        $sumn      +=  $coun                    if($char=~ /^[0-79]$/       ); # special sum of Non-8 digits to compare at end
        $jus8       =  $coun                    if($char=~ /^8$/            ); # special just       8        to compare at end
        $w82o      .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
    } # $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,$z    %4d$B;\n",cma($coun),b8colr(sprintf("%4s",b64($coun))),$cndx); 
  }   # $Stxt.="\n"; # just disabling now redundant double-long single column full counts list output, but still keeping the 8 vs. other digit counts
  for     my $cndx (0..int($#ccnt/2 )){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    if($cndx < int($#ccnt/2)+1){ # +1 was abov with @ccnt nstd of $#ccnt && originally had the +1 inside the int() call here
      for my $char (sort(keys(%fulc))){ # then above CharCouniNDeX loops just unique counts && (was Probably) PrintCouNT before Wait to Output8
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
      } $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,",cma($coun),b8colr(sprintf("%4s",b64($coun))));
    } $coun=$ccnt[int($#ccnt/2)+$cndx+1];                       $pcnt=0;   $w82o=''; # restore conditions for always 2nd column for now (ad optn l8r)
    if(defined($coun)){ # odd number of chars may leave last invalid coun so check   # abov hook used to be ?1:0 but now testing whether necessary
      for my $char (sort(keys(%fulc))){ # no longer trying to sum non-8 digitz during 2-column printing down here, doing it once during the single column abov
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # belo was once trying some random colrz with: ,S(substr($cmap{'d8bo'},b64(int(rand(8))),1)));
      } $Stxt.=sprintf((' ' x ( 8-$pcnt))."$C$w82o$B:$M".sprintf("%7s$B: %s$W,\n",cma($coun),b8colr(sprintf("%4s",b64($coun)))));
    } } $Stxt.=sprintf("$C  Sum of$B: ${G}0$W..${G}7$W,${G}9$B: $M%s$o      dif$Y:$B%7s$W;$z",cma($sumn),cma($jus8-$sumn));} $Stxt=sS($Stxt) unless($clrf);
open my $out8,'>&',STDOUT or die "Can't open  duplic8 STDOUT handle: $!";binmode $out8,':encoding(UTF-8)';print $out8 $Stxt; # crE8 local duplic8 of global
close   $out8             or die "Can't close duplic8 STDOUT handle: $!";
