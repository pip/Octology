#!/usr/bin/perl
# D6OMHm3L:8plc crE8d to read PipStuart's <Pip@CPAN.Org> 8.txt (mainly 2 specific columns) to tabul8 && print the 8 Precursor Letter Counts;
# 2du:4 -g map try colrng blox by midlmap4mor vivid PreLetr grup assoC8nz (&& recolr ion or othr sufxz whN grup colr is alsO Blu or Cyan),
#     4 -g gM8ria:try2add sumz,productz,modez,meanz,medianz,cnsidr delta difz&&r8ioz,prIm factrz,add colrz,graph rangez,iconz,contMpl8 othr good posibl repz,
#       also try deltas with sub-colr 4grndz by magnitude gradu8ionz or syswIdfrEqz,try various b64 xor && bAsic prOgrSiv charhash techniquez4usualyUniqrepz,
#     4 -g:try reloopng 4 Ech singl rOw alInmNtz nstd of init blox,fix all -p pg1f to count up to actual linz rather than hardcode 160x48 limitz,
#   mAB try more agrSiv minimIz8ion of gM8ria prImz whN l8r sufx or prEfx alreD in PLz,alsO try special rEordr of lRgSt prEfxz2trim dn rAng,
#   add dur8z around sectnz&&mAB try2optimIz per4manc of slOSt pRtz(tkz about 12-18secs for basic to -all),
#   mk sepR8 tabul8ion of 8-words used in l8r document8ion wi not8ion 4thOs not yet included in top lists (thN optn2ignor easy conjug8ions && pre/suffixes),
#   mk easy optn4 fulc 2use 1colm 4grep,add 4m@d percNtz,stuD wc && mk a8:cnt8/8c wi fulc -f? && 8plc as -l? optnz(rEdo hedrtXt),colr letrz,add f0ntz4 8trm;
use strict;use warnings;use utf8;use v5.10;use Octology::a8;use Octology::b8;
my $d8VS='I62M7TOW';       my $clrf=1;my $fulf=0;my $argz='';$argz= join(' ',@ARGV) if(@ARGV);my $Stxt='';my $Smap='';my $folf=0; # add 4-Or-Less-Flag
my $edVS=        '';       my $pg1f=0;   $pg1f=1 if($argz=~ /(^|\s)-?-?[^p]*p/i); # find -?p(age) flag2limit some extra long output to first 48-line page
my $clmz=        80;       my $lpsf=0;   $lpsf=1 if($argz=~ /(^|\s)-?-?[^l]*l/i); # find -?LetrPrecursShortsFlag  # if MaXWordSize evr grOz,wil nEd2incrEs|Dtct
my $linz=        24;       my $gm8f=0;   $gm8f=1 if($argz=~ /(^|\s)-?-?[^g]*g/i); # find -?g(m8r) flag2count&&adorn wi math 4mUl8ions stRting wi 2letr
                           my %fulc=();  $fulf=1 if($argz=~ /(^|\s)-?-?[^f]*f/i); # find -?f(ull) flag to count && sort all         characters at end
                           my @folc=();  $folf=1 if($argz=~ /(^|\s)-?-?[^w]*w/i); # find -?w(ord) flag to count && sort all maximum char-words at end
                           my %lpsd=();  $clrf=0 if($argz=~ /(^|\s)-?-?[^s]*s/i); # find -?s(SKp) flag arg4vim ':r!8plc s' 2B lIk ':r!8plc|sS'
$clmz=$ENV{'COLUMNS'} if(exists($ENV{'COLUMNS'})); # mAB also Dtect H varE8ionz   # now MaXimumWordSize && CoLuMnof8 && Pre-letrz R Dtectd dynamicly(!hRdcOded)
$linz=$ENV{'LINES'  } if(exists($ENV{'LINES'  }));my $lnmx=$linz - 2;my @jd8a;my $mxws=8;my $clm8= 8;my $clmp=$clm8-1;my $rcnt=0;
if($argz=~ /(^|\s)-?-?[^a]*a/i){   $lpsf=$gm8f=$fulf=$folf=1;} # set All optional section flags at once for any -a parameter
if($argz=~ /(^|\s)-?-?[^h]*h/i){$Stxt.=" $0 - 8.txt Precursor Letter Counter d8VS:$d8VS by: $auth to gener8 Octology applic8ion 8-words d8a analysis;
  h   - print this Help text and exit; below options are flags which can be combined in any order, but l8r sections print in comput8ion order;
  s   - print below options as just plain text (Strip default eScape color codes,like running `$0 | sS` strip eScape post-process);
  p   - print below options as limited to just first $lnmx-line Page instead of default everything (fixed 160x50 single Pages work for -l -w -g);
  a   - print All extra options below (like calling `$0 lwgf`)   (with -p limiting most sections to  160x50 just 1 Page of output for each);
  l   - print Letters of precursors sorted by size with colors     (with -p only printing up to z 110 and cutting off before c 142 as 1 Page);
  w   - print Words sorted by size up to current maximum of 19     (with -p only printing from  2 to  8 for just first $lnmx-line Page);
  g   - print gM8ria 'Gematria' word valU8ions in aligned sections as preliminary trial of a few short approaches to some numerology;
  f   - print Full character counts (maybe l8r extracted to a8:cnt8 and `8c` like `wc`);";
  if(20 < $clmz && $clmz < 160){my @htxt=split(/\n/,$Stxt);$Stxt='';my $lsiz;my $tokn;for(@htxt){$lsiz=0;while(s/^(\s*\S+)//){$tokn=$1; # smRt split Help tXt
        if($lsiz + length($tokn) > $clmz){$Stxt.="\n" . (' ' x 8);$lsiz=8;$tokn=~ s/^\s+//;} $Stxt.=$tokn;$lsiz+=length($tokn);} $Stxt.="\n";}}o8($Stxt);exit;}
my $efyl ='8.txt';my @lcnt;$lcnt[$_]=0 for(0..b10('z'));my @acnt;$acnt[$_]=0 for(0..b10('z'));my $donw=0;my $t0tl=0;my $text;my $actx;my $sclc;my $gttl=0;
unless(-r         "$efyl"){$efyl=$ENV{'HOME'} . "/dox/2du/$efyl" if(exists($ENV{'HOME'}));} # try2add likely path when file not in local dir
open(my $eflh,'<',"$efyl") or die "!*EROR*! Couldn't open eight-file to read counts! $!";binmode $eflh,':encoding(UTF-8)';
while( <$eflh>){my $ldat=$_;$donw=1 if(/^$/); # sets DONe-Words true when 1st blank line found (shud be 1-based line#:8-word cnt+1blnk+6cmnt-hedr,4now)
  if(/^#.*?\$d8VS\s*=\s*(['"])([0-9A-Za-z._]{8})\1\s*;/){$edVS=$2;} # this match regex seems to still need \1 && presumably ${1} would work in s/// replacement
  if  (!$donw &&   $ldat  !~ /^\s*#/){ # the header lines (&& potentially l8r blocks) have pound as first non-whitespace character design8ing comments to skip
    if     (length($ldat) >= $clm8  ){my $pltr; # 16th colm is l8st dflt 8 loc8ion,but some l8r found very long 8-words could slide furthr so now srch 15+
      if   (       $clm8  <=     8  ){while(length($ldat) >= $clm8 && substr($ldat,$clmp,1) ne '8'){$clmp=$clm8++;}} # non-hedr 8-word loop up2 dflt 8colm
      if   (substr($ldat,    $clm8,1) eq     '8' ){$pltr=substr($ldat,$clmp,1);} # no more hard-coding colmz as aligned interest (was 14 && 13, then 16 && 15)
      elsif(       $ldat  =~ /^.*?(\w)        8/x){$pltr=$1;} # for any lines with very long 8-words, if the 8 wouldn't fit the dflt colm srch for 1st 8
      if   (       $ldat  =~ /^\s*(\w{0,$clmp}8\w*)(\s|:)/i && ($folf || $gm8f || $lpsf)){my $ewrd=$1; # if mAB FindOrdrdLsFlag,thN lOdup Cntz arAyof subhashz
        push(@{$lpsd{$pltr}[        length($ewrd)]}, $ewrd)  if($folf || $gm8f || $lpsf); my $wsiz= length($ewrd);$folc[$wsiz]{$ewrd}++; # do Xtra duplic8ion
        print                   "$R!*EROR*! duplic8 of wsiz:$wsiz for ewrd:$ewrd to remove l8r;$z\n"           if($folc[$wsiz]{$ewrd} > 1); # error check
        $mxws=$wsiz if($wsiz > $mxws);} # this upd8z MaXimumWordSize for l8r loop limit8ionz && abov push bildz LetterPrecursorShortestsD8a struct for -l pRam
      $rcnt                ++   if(defined($pltr) && $pltr  eq 'r'); # track sepR8 max count for scaling size barz below in $blsz nstd of old hardcoded 40
      $lcnt[b10(   $pltr )]++   if(defined($pltr));}} # wrapng $pltr in lc() B4 b10() shOz just 23(/35) countz in rEvrs ordr:rcln etzg mdvp ubsf xhkw ioy
      $text .=     $ldat;       if($fulf){my @chrz= split(//,$ldat);for my $char (@chrz ){$fulc{$char}++;}}} # !lc:rcln Etzg mdpv bsuC DLNR UVGf xBhk wIMP OSy
my    $letz  =join('',keys(%lpsd)); # these PLz won't be in order, but should be good enough for regex char-classes; abov lc() 23 ruinz 12 grupz in2 15 nstd
close($eflh)               or die "!*EROR*! Couldn't close eight-file after reading! $!";
#if($fulf){%fulc=();for(split(//,'the of and to a in is I that it for you was with on as have but be they')){$fulc{$_}=0 if(!exists($fulc{$_}));$fulc{$_}++;}}
# temporarily try to hijack fullcharcounts above to just look within top 20 English words to compare; should extract ccnt to be like this && wc wi vary columnz
# results: Idrv:1, bfuwy:2, ns:3, ei:4, oh:5, a:6, t:8, ' ':19; # "I drive by your freeway and say 'oh a tea Space!'"
while($text=~ s/(\w)8//){$acnt[b10($1)]++;}   # counts chopping out all PLs && 8s
my @scnt = sort { $a <=> $b } (@lcnt);my $pttl=0;my $apcn=0;
for(my $sndx=$#scnt;$sndx >= 0;$sndx--){
  if(($sndx > 0 && $scnt[$sndx] == $scnt[$sndx - 1]) || ($sndx == 0 && $scnt[0] == 0)){splice(@scnt,$sndx,1);}} # below2 sepR8 prnt blox for not color or with
$Stxt.=                               sprintf("${C}8${M}Pre-cursor${Y}Letter${R}Counter$W:$G d8VS$C=%s$G\n",            d8c($d8VS));
my $efsz = length($efyl);$Stxt  .=    sprintf("$O  efyl$C=%s".' 'x (18-$efsz).$G.          " edVS$C=%s$G\n",c8fn($efyl),d8c($edVS));
$Stxt.=                                       "${C}8${M}Pre${Y}Letr$R Ct$C Full${W}Document${R}Counts$Y Sz${p}b10${M}Ct${G}Percent$W%\n";
$Stxt.=                                       "$B-------- -- ------------------ ---------------\n";
for(@scnt){for my $lndx (0..$#lcnt){ # just loop initially to Pre-compute the ToTaL for l8r gener8ing Percentz Per Pre-letter group as they get Processed2Prnt
    if(defined($lcnt[$lndx]) && $lcnt[$lndx] == $_){                                     $pttl+=$_;}}}
for(@scnt){my @ascz=($R,$W,$C,$Y,$M,$o,$B,$G);                                                     $sclc=0;$actx ='';
  for          my $lndx (0..$#lcnt){ # for the Ansi eSCape ColorZ with the rot8ing PerCeNt iNdex below, skip over Cyan,Green,&& OldOrange for betr contrast
    if(defined($lcnt[$lndx]) && $lcnt[$lndx] == $_){$Stxt.=   $Y           . b64($lndx) ;$t0tl+=$_;$sclc++;$actx.=' '.b8c(sprintf("%2s",b64($acnt[$lndx])));
                                                                                         $gttl+=$acnt[$lndx];}} # swap Cyan or Green wi Magenta4percNtz BlO?
  my $spad=33 - 3*$sclc;$spad=0 if($spad < 0);$actx.=' ' x ($spad - 14);$actx.=$ascz[$sclc] if(defined($ascz[ $sclc         ]));my $apcS=$ascz[++$apcn % 8];
  $apcn++     if( $apcn =~ /^(2|4)$/        );$actx.= $sclc;$actx.= $ascz[ ($sclc + 4) % 8] if(defined($ascz[($sclc + 4) % 8]));my $apcx=$apcS;my $prcs;
  $apcS = $ascz[ ($sclc + 0) % 8] if(defined($ascz[($sclc + 0) % 8])); # test matching percent numbz with group sizes && percent charz with 'x' multiplierz
  $apcx = $ascz[ ($sclc + 4) % 8] if(defined($ascz[($sclc + 4) % 8]));$prcs=sprintf("%8.3f",$t0tl*100.0/$pttl);$prcs=~ s/(\.)/$W$1$apcx/;#prcs=~s/(000)$/$K$1/;
  $apcS=$G    if( $apcS eq $G);$actx.=sprintf("x$M%4d%s%s%s%%%%",$_,$apcx,$prcs,$apcS);$apcn-= 8 while($apcn > 7); # SKpng percNt4l8r sprintf BlO
  my $blsz=int($rcnt/6);my $r8io=$blsz /64.0 ; # prEpadNdof acnt ndxzB4 sclc flipz4stRtngletrcolm  # top4grupz8+1joy directnz rcln Etzg+m cover almost 79% wrdz
  $sclc   = 9 -   $sclc;$sclc=0 if($sclc < 0); # gener8ing bar-graphs of b8 Counts across remaining line widthz  # botm8grupz dpvb suCD LNRU VGfx B... last 21%
  if($clmz >= 160){my  $ddig =$_   ;$actx.=' ' x abs(112-int($_*$r8io)); # (96-int($_/2)) wi spad=50-3*sclc abov,thN (114-int($_*$r8io)) wi spad=32-3*sclc
    while($ddig >= 64){$ddig-=   64;$actx.= $o . ('#' x  ($blsz- 1)) . "$R@";} my $mdig=$ddig % 2; # try2mk Orange 2nd blox Nd in last Red boundry
                       $ddig*=$r8io;$actx.= $R . ('#' x   $ddig    ); # odd mod rEmAndr BlO reprEsNtd betr whN Ech 64 blok fitXactly32chrz,sO just4 sOlO 1now
    if($mdig && ($blsz==32||$_==1)){$actx.= $R .  '1'               ;}} # outr colm widt tSt shud only draw bRz 4 wId termz now
  $Stxt.=' ' x   $sclc;$Stxt.=                     sprintf(  "%s $actx\n",b8c(sprintf("%2s",b64($_))));}
                                                                                   my $ct0t=$M . cma($t0tl);$ct0t=~ s/(,)/$Y$1$M/g; # pre-colr comma'd t0tal
$Stxt.=                                            sprintf   "$B-------- -- ---\n";my $cttl=$B . cma($gttl);$cttl=~ s/(,)/$Y$1$B/g; # pre-colr comma'd total
$Stxt.=                                            sprintf("${C}t${M}0${C}tlz    %s %s $z(${r}b64$z)$W  :  $z(${p}b10$z) %s   %s$W;$z",
                                                    b8colr(sprintf("%2s",b64($t0tl))),b8colr(sprintf("%2s",b64($gttl))),$ct0t,$cttl);
$Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';  print  "$R!*EROR*! pttl:$pttl != t0tl:$t0tl;$z\n" if($pttl != $t0tl); # error check expecting t0tal match
if($lpsf){$Stxt.="\n${W}All${R}Counts${o}Not${M}Matching${C}Words${B}List$G -$K likely from just d8-stamps, pal8 codes, or other non-word strings with 8";
  my $ptot=0;my @acor;my $slin= '';$Stxt.=" (ordered by freq then letr)$W:\n"; # PrevrowTOTalwidth, AllCountsORdered, SortedLINe
  for(0..63){if(defined($acnt[$_]) && $acnt[$_] && !exists($lpsd{b64($_)})){$slin.="$C ".b64($_)."$W:";$slin.=$r;$slin.=$R if($acnt[$_]>2);$slin.=$acnt[$_];
      push(@{$acor[$acnt[$_]]},b64($_));}}
  for(0..63){if(defined($acor[$_]) && $acor[$_]){$Stxt.=" $R";$Stxt.=$r if($_ <= 2);$Stxt.=b64($_) . "$W:$C" . join('',@{$acor[$_]});}} $Stxt.="\n$slin";
  $Stxt        .="\n${Y}Letter${M}Pre-cursor${C}Shortests${B}List$G -$K shows all entries by$M P${Y}L$K with growing word-sizes$W:\n\n";for(@scnt){
    last if($_ >= 128 && $pg1f); # for single -p page try to skip out after Etz 110 && before cln 142
    for     my $lndx (0..$#lcnt){if(defined($lcnt[$lndx]) && $_ ==   $lcnt[    $lndx]){my $letr=b64($lndx);
        my                                                                 $rtot=2 ;   my $ltot=     0    ;$Stxt.="$Y$letr$R:"; # hRdcOded prEnwlInz abov
        for my $wsiz (2..$mxws ){if(exists ($lpsd{$letr}) && defined($lpsd{$letr}       ) && scalar(@{$lpsd{$letr}       }) &&
                                                             defined($lpsd{$letr}[$wsiz]) && scalar(@{$lpsd{$letr}[$wsiz]})){
            if    ($rtot + length($wsiz                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
            $rtot        +=length($wsiz                     ) + 1          ;$ltot+=          scalar(@{$lpsd{$letr}[$wsiz]});$Stxt.="$B$wsiz$W:$z";
            for my $wndx (0 .. $#{$lpsd{$letr}[$wsiz]}){
              if  ($rtot + length($lpsd{$letr}[$wsiz][$wndx]) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
              $rtot      +=length($lpsd{$letr}[$wsiz][$wndx]) + 1 ;  $lpsd{$letr}[$wsiz][$wndx]=~ s/(8)(ion)$/$1$C$2$z/;     # colr most comon ion sufx
                                                                     $lpsd{$letr}[$wsiz][$wndx]=~ s/($letr)(8)/$o$1$G$2$z/g; # colr 8PLz
              $Stxt      .=       $lpsd{$letr}[$wsiz][$wndx]  .' ';}}}
        if        ($rtot + length($ltot                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
        $rtot            +=length($ltot                     ) + 1 ;                      $Stxt.=  "$M$ltot ";
        if($ptot + $rtot <= $clmz){$Stxt=~ s/(.*)\n/$1/s;$ptot+=$rtot;}else{$ptot=$rtot;}$Stxt.="\n";$rtot=0;}}}} $Stxt=~ s/\n$//;
$Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
if($folf){$Stxt.="\n${Y}Word${R}Sort${C}By${B}Size$G -$K up to current maximum$M $mxws$K or one$p page$K if given$p -p$W:\n";my $maxs=$mxws;$maxs= 8 if($pg1f);
  for   my $wsiz (2..$maxs ){my @folk=sort(keys(%{$folc[$wsiz]}));$Stxt.= $B.sprintf("%${wsiz}d ",scalar(@folk));my $rtot=$wsiz+1;
                                                                  $Stxt.="$R $wsiz"        unless(scalar(@folk));
    for my $fndx (0..$#folk){my $foln=$folk[$fndx];if($rtot + length($foln) + 1 >  $clmz){$Stxt.="\n";$rtot=0  ;} $rtot+=length($foln)+1;
                                $foln=~ s/(8)(ion)$/$1$C$2/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;$Stxt.="$z$foln ";} $Stxt=~ s/ $/\n/;}} # $Stxt.="$G @folk\n";
$Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
# I47M1b96:just l8st 2z 3z 4z,nEd2cut ? 2fit nXt `sumb 2` 96 pAg,b8 c8 d8 g8 w8 ckm8 pal8 upd8 alredy bin is 8,DlA sumb4 N8 DN8 NfN8 SSN8 as obtuse:
#  9   f8   h8   k8   l8   m8   p8   r8   s8   y8  # 9+35=44,nEd 40 of 73 4z (isol8ing 33 worst for l8r) to accept l8st 12 over in bin to complete next 96
# 35  aV8  ab8  ag8  al8  aw8  b8a  bl8  cS8  cr8  el8  f8h  f8l  fL8  fr8  gM8 gr8 iD8 ir8 mL8 n8l oP8 or8 pN8 pl8 pr8 rN8 sN8 sk8 sl8 sp8 st8 sw8 tr8 ur8 vL8
# 73 abl8 aer8 agn8 ans8 aur8 bel8 ber8 bin8 bor8 bov8 col8 crE8 crN8 cur8 deV8 deb8 dil8 don8 elu8 equ8 est8 exP8 fix8 gyr8 ing8 inm8 inn8 ion8 jub8 jug8 kin8
#    l8nt lan8 leg8 lig8 loc8 lor8 lun8 lux8 lyr8 lys8 mal8 meD8 mec8 met8 mic8 mor8 mut8 neg8 not8 nov8 obV8 obl8 orn8 phN8 pir8 pup8 r8io raD8 reb8 rel8 rot8
#    rug8 s8E8 sav8 sed8 soC8 stL8 str8 tan8 unE8 vac8 zon8. 3rd page sumb could be last 33 4z then nXt bSt 63 of 118 5z (leaving 55, with near half for l8r);
if($gm8f){$Stxt.="${W}Gener8 gM8ria primes for names by$B 3$W segments (${Y}PreLetters$W,$G Suffixes$W,$C Prefixes$W)...\n$G"; my $eqfz='';my $eqct=0;
  my %w2pm;my %wh2p;my @wpls;my %kvs8;my %pl8z;my %sufz;my %prez;my %pl8s;my %sufs;my %pres;my %allc;my %allp;my @plrl;my %ppbs;my $bbct=0;my $colc=0;
  my $mxpa=1;#$mxws=19;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){$pl8z{$2 }=0 unless(exists($pl8z{$2 }));$pl8z{$2 }++;
        if(defined($1) && length($1)     ){$prez{$1 }=0 unless(exists($prez{$1 }));$prez{$1 }++;}
        if(defined($3) && length($3)     ){$sufz{$3 }=0 unless(exists($sufz{$3 }));$sufz{$3 }++;}
        else                              {$sufz{'_'}=0 unless(exists($sufz{'_'}));$sufz{'_'}++;}}}}
  for   my $kyst (sort(keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){$Stxt.=sprintf("${Y}plct$W:%s$M%4d$Y pl8z$W:$o%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++)                             ;}} %kvs8=();#$Stxt.="\n";
  for   my $kyst (sort(keys(%sufz))){push(@{$kvs8{$sufz{$kyst}}},$kyst);} # nice that there are exactly 8 count categories of sufz, 14 PLz, 6 prez (28 totl)
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){if(@{$kvs8{$kvct}} == 1 && $kvs8{$kvct}[0] eq  'ion'){
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:${B}ion\n",b8c(sprintf("%3s",b64($kvct))),$kvct);}else{
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));}
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}} %kvs8=();#$Stxt.="\n"; # try to reuse earlier segments
  for   my $kyst (sort(keys(%prez))){push(@{$kvs8{$prez{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){my $s8ls='';my $rtot=18; # bild up an rtot to pump newlinez into s8ls before appending wider than clmz
    for my $ssvl (sort(@{$kvs8{$kvct}})){if($rtot + length($ssvl) + 1 >= $clmz){$s8ls.="\n";$rtot=0;} $rtot+=length($ssvl) + 1;
      $s8ls.=S(substr('YCMGRBop',b10(substr($ssvl,0,1)) % 8,1)) . "$ssvl ";} $s8ls=~ s/ $//;
    $Stxt.=sprintf("${C}prct$W:%s$M%4d$C prez$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,$s8ls);
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}}                # try to keep reusing earlier segments
  $Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
  $Stxt  .="${W}gM8ria primes with$B 3$W sepR8 sections:$Y PL$W,$G suffixes$W,$C prefixes$W but with special case 1st$G suffixes$W:$z _$W &&$B ion$W for ";
  $Stxt  .="smaller highest nums...\n";
  %pl8s=();%sufs=();%pres=();%w2pm=();%wh2p=();%kvs8=();@wpls=();%allc=();%allp=();$bbct=$colc=0;$mxpa=1;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        push(@{$ppbs{$pltr}},$pfix) if(length($pfix));}}}
  for   my $kyst (sort(            keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}          $allp{prim($mxpa)}='_'  ;$sufs{'_'  }=prim($mxpa++);
                                                                                               $allp{prim($mxpa)}='ion';$sufs{'ion'}=prim($mxpa++);
  for   my $kvct (sort {$b <=> $a} keys(%kvs8) ){for my $sprt  ( sort(@{$kvs8{$kvct}})       ){$allp{prim($mxpa)}=$sprt;$pl8s{$sprt}=prim($mxpa++);
                                                                                                                unshift(@plrl,$sprt)              ; }}
 #for   my $pdig (0..3                         ){                                              $allp{prim($mxpa++)}="$pdig";} # pad4digitz2grow curNt stably?
  for   my $kyst (sort {length($a) <=> length($b)} sort(keys(%sufz))){if($kyst !~ /^(_|ion)$/){$allp{prim($mxpa)}=$kyst;$sufs{$kyst}=prim($mxpa++); }}
 #for   my $pdig (4..7                         ){                                              $allp{prim($mxpa++)}="$pdig";} # digz wil nEd2ch if evrin spLng
  for   my $pltr (      @plrl                  ){for my $sprt  (      @{$ppbs{$pltr}}        ){unless(           exists($pres{$sprt})){ # rvrs much worse 270M
                                                                                               $allp{prim($mxpa)}=$sprt;$pres{$sprt}=prim($mxpa++);}}}
  $Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
  $Stxt  .="${z}pres${C}By${B}Size$W:$z";my $rtot=11;for my $sprt (sort {length($a) <=> length($b)} sort(keys(%pres))){
    if($rtot + length($sprt) + 1 >= $clmz){ $Stxt.="\n";$rtot=0;}
    $rtot    +=length($sprt) + 1;           $Stxt.= S(substr('YCMGRBop', length($sprt) % 8,1)) . "$sprt ";} # colr sequ by size
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        my $cmps=$pl8s{$pltr};$cmps*=$sufs{$sfix}   if($sfix ne '_' || $pfix);$cmps*=$pres{$pfix} if($pfix);$wh2p{$cmps}=$curw;$w2pm{$curw}=$cmps;
        $bbct++ if(length(b64($cmps)) >  length($curw)); # count b64 versions of composite numbers that are longer than (or same as) 8-word they refer to
       #$Stxt.=sprintf("$z%19s%s$C%2d",$curw,b8c(sprintf("%5s",b64($cmps))),$bbct);if(++$colc==6){$colc=0;$Stxt.="\n";}
      }}} $colc=0;$eqct=0;$eqfz='';$Stxt=~ s/\n?$/\n/; # now 0/1238 have longer b64 numrep than referred 8word
  for   my $kyct (sort {$a <=> $b} keys(%wh2p)){my $vwrd=sprintf("%20s",$wh2p{$kyct});for my $nndx (1..4){if(substr($vwrd,-1*$nndx,1) eq '8'){my $sfsz=5-$nndx;
        $vwrd=~ s/^(\s{$sfsz})(.+)$/$2$1/;last;}} # right-align the 8 column for almost all words (except when suffix is longer than 4 chars)
    $vwrd    =~ s/^(\s*dil88ion\s*)(\s)$/$2$1/;   # special-case alignment correction to 1 extra space for '88ion'
    $vwrd    =~ s/([A-Z])(8)/$Y$1$G$2$z/gi;my $tkct=$kyct;my $twrd='';my $tpmz='';my $sfxf=0;for my $tprm (sort {$a <=> $b} keys(%allp)){
      if   (($tkct % $tprm) == 0              ){$tpmz.="$tprm,";$tkct/=$tprm;  # mA nEd2filtr out 0..7 pad digitz,thN add special sufx ckz4 _|ion 1st, ...
        if   (length($twrd) == 0              ){                               #   ...thN get reqd PL,thN mAB othr sufx,fInalE prEpNd any rEmAning prefix
          if ( $allp{$tprm} =~ /^(_|ion)$/    ){$twrd = $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
          else                                 {$twrd ="$allp{$tprm}8"     ;}} # stil quite simpl3sections always in ordr (Xcept special _|ion sufxz)
        elsif(length($twrd) == 2 && $sfxf == 0){$twrd.= $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
        elsif($twrd =~ /^(ion)$/ && $sfxf == 1){$twrd ="$allp{$tprm}8$twrd";}  # 27,676,799 ostent8ious last (wi 8 pad digitz,4btwn sectnz 4 mor stabl growth)
        else                                   {$twrd ="$allp{$tprm}$twrd" ;}}}# 25,308,869 ostent8ious last (after some additions && removing 8digit padding)
    $tpmz=~ s/,$//;my $trmc='!';if($wh2p{$kyct} eq $twrd){$trmc=';';$eqct++;}else{$eqfz.="$G$wh2p{$kyct}$W:$B$twrd$W, ";} $vwrd=~ s/(ion\s*)$/$B$1/; # tryBlu
    if($pg1f){last if($kyct> 106426);$Stxt.=sprintf("%s$z%s$W%s",b8c(sprintf("%4s",b64($kyct))),$vwrd,$trmc);if(++$colc == 6){$colc=0;$Stxt.="\n";}}
    else     {    $Stxt.=sprintf("$M%11s %s$z %s$W%s",cma($kyct),b8c(sprintf("%5s",b64($kyct))),$vwrd,$trmc);if(++$colc == 4){$colc=0;$Stxt.="\n";}}
  } $eqfz=~ s/, $//;  $Stxt=~ s/\n?$/$W\n/;$colc=0;#Stxt.="eqct:$eqct totl:" . scalar(keys(%wh2p)) . " eqfz:$eqfz"; # rebild Cmz2alreDB fIn4 100% of cur8wrdz
  $Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
  open my $log8,'>',"$ENV{'HOME'}/.log/8pc.ls" or die "Can't open  log 8PrimesComponents.LiSt file handle: $!";binmode $log8,':encoding(UTF-8)';
  print   $log8 "# $d8VS:~/.log/8pc.ls gener8d by 8plc with 8.txt edVS:$edVS to save sepR8 reference to 8-word prime maps by PipStuart <Pip\@CPAN.Org>;\n";
  for  my $prmk (sort {$a <=> $b} keys(%allp)){print $log8 sprintf(" %3s %-14s",b64($prmk),$allp{$prmk});if(++$colc == 8){$colc=0;print $log8 "\n";}}
  close   $log8                                or die "Can't close log 8PrimesComponents.LiSt file handle: $!"; # try2wrItout prImz list for l8r sepR8 rFrNc
          delete($folc[2]{ 'N8'});delete($folc[2]{  'b8'});delete($folc[2]{  'c8'});delete($folc[2]{  'd8'});delete($folc[2]{  'g8'});delete($folc[2]{  'w8'});
          delete($folc[3]{'DN8'});delete($folc[4]{'NfN8'});delete($folc[4]{'SSN8'});delete($folc[4]{'ckm8'});delete($folc[4]{'pal8'});delete($folc[4]{'upd8'});
          delete($folc[5]{'m8rix'});delete($folc[5]{'coll8'}); # not sure if coll8 is best 2nd to remove of 5z, but m8rix is probably good enough as p8:m8rx
 #$Stxt  .="${W}gM8ria primes with altern8ing sections of next most prevalent remaining character (when any next none-left indic8or on one side drops):\n";
  # so maybe figure out best new structures && altern8 composite ordered escal8ing prime approach allowing for next component to be most popular long string
  my   @alpn;my %pctz;my %sctz;my @pfxz;my @sfxz;my $done=0;my $pfxf=0;my $sfxf=0;$colc=0;$mxpa=1;#%pl8s=();%sufs=();%pres=();%w2pm;%wh2p%kvs8@wpls%allc$bbct
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # maybe this attempt will be quite similar to a trie retrieval graph on next letters?
    for my $fndx (0..$#folk){my $curw=$folk[$fndx]; # nEd2justkEp loopng thru all primes next altrn8ng acceptance && rEplAyng
      if($curw=~ /^(\w*?([A-Z]))8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1)&& length($1));
        push(@pfxz,$pfix) if(length($pfix));     # preletrs remaining should just prepend reverse prefixes so wrapped $1 above around $2 to just ignore pltr
        push(@sfxz,$sfix) if(length($sfix));}}}  # need new or reuse flagz for all suffixes or prefixes completely termin8ing for just remainder of opposite
  while(!$done){%pctz=();%sctz=();$pfxf=$sfxf=0; # maybe initial flagging for done && side termin8ors && can build up all biggest nexts
    # maybe rethink a bit && just push all pfix && sfix to @?fxz for p s PipStuart PreSuffix PlainSwamp to just reloop apart right around 4 nxt bst cnt
    # while altern8ing consumption, might track pending termin8 suffix processing as like a competing string for sided st8us popularity becomes priority...
    #   but still may mainly be left with a really long tail of tons of single jumbled characters, or maybe require higher aggreg8ion prior to prime alloc8
#   if   (scalar(@alpn) % 2 &&   !$pfxf){$pctz{substr($pfix,-1,1)}++;} # probably can't just modulo 2 since also must flag pre or suf already finished too
#   elsif($sfix             eq  '_'    ){$sctz{       $sfix      }++;} # kinda abandoning ship on this method of too many small top single-char strings
#   elsif($sfix             =~  /^(\w)/){$sctz{       $1         }++;} # theoretically might be able to cmp max next solo char vs. top pairs * 2 broaden size
#   else                                {$sctz{        '.'       }++;} # maybe try adding '.' dot all suffix completed by that point
    $done=1; } # set @alpn= sided strings in prime alloc8 order for prim($mxpa++) = nxt alloc8ionz && $done=1 when none left
  # want to start right _ 880 empty suffixes but then may want to postpone alloc8ing another maybe . dot code for termin8ing past all popu suffix nexts
  # pretty complex to keep counting up exclusively the highest current stage then to adopt && recompute from only remainders after earlier selections
  # actually maybe closing suffixes after just running all next best single letters;  @plrl should have PreLetrsRvrsList, but need combining counts l8r;
# open my $log8,'>',"$ENV{'HOME'}/.log/8ps.ls" or die "Can't open  log 8PrimesSidestring.LiSt file handle: $!";binmode $log8,':encoding(UTF-8)';
# print   $log8 "# $d8VS:~/.log/8ps.ls gener8d by 8plc with 8.txt edVS:$edVS to save sepR8 reference to 8-word prime maps by PipStuart <Pip\@CPAN.Org>;\n";
# for  my $prmk (sort {$a <=> $b} keys(%alpn)){print $log8 sprintf("%-4d %-15s ",$prmk,$alpn{$prmk});if(++$colc == 7){$colc=0;print $log8 "\n";}}
# close   $log8                                or die "Can't close log 8PrimesSidestring.LiSt file handle: $!"; # try2wrItout prImz list for l8r sepR8 rFrNc
  my %jmap=('c'=> 0,'z'=> 1,'l'=> 2,'t'=> 3,'n'=> 4,'E'=> 5,'r'=> 6,'g'=> 7,'m'=> 8,'d'=> 9,'p'=>10,'v'=>11,'b'=>12,'s'=>13,'u'=>14,'C'=>15,'D'=>16,'L'=>17,
            'N'=>18,'R'=>19,'U'=>20,'V'=>21,'G'=>22,'f'=>23,'x'=>24,'B'=>25,'h'=>26,'k'=>27,'w'=>28,'I'=>29,'M'=>30,'P'=>31,'O'=>32,'S'=>33,'y'=>34);
  my @jmls=(split(//,'czltnErgmdpvbsuCDLNRUVGfxBhkwIMPOSy'));%jmap=();my $A=S('A');my $D=S('D'); # cycljoystkdirzfrm dn clkwIs aroun,mAnEd2rEordrl8rloopz4wIndz
  my %sepm=();my $bwid=53;my $shsf=1;my $boff;my $jbnx;my $prlt;my $rosl;my $hbwd;my $stal;my $s=5;my $t=' ' x $s;my $bhwd=int($bwid/2);my %pwsf; #PrntdWzSoFar
  for   my $pndx (0..$#jmls){$jmap{$jmls[$pndx]}=$pndx;} # try2gNr8 rvrs lookup of pre-letters to indices
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # if disabling the suffixes, the percentage covered only bumps up to about 71% 926 shown
    for my $fndx (0..$#folk){my $curw=$folk[$fndx]; # should be able to set SHowSuffixFlag to zero to disable suffix inclusion again whenever easily now
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1)&& length($1));
        my $sfcl=$B;$sfcl=$C if($sfix ne 'ion'); # Wow! echoing all 8 blox && piping thru `wc -w` yielded exactly 888 =) I5LM6d8a:now last 9 PLz are 898<3;
       #$sfix   =   'n'      if($sfix eq 'ion'); # try to cram more 8-words into blox shrinking "io" out from common suffixes
       #if($pltr=~ /^[mdpvbsuCDLNRfxMGkwVBIhUP]$/){$sepm{$pltr}[0] ="$Y$pltr${G}8$W:$z " unless(exists($sepm{$pltr}) && length($sepm{$pltr}[0]));} # lOd sepR8
        if($pltr=~ /^[mdpvRfxMuLVBI]$/){$sepm{$pltr}[0] ="$Y$pltr${G}8$W:$z " unless(exists($sepm{$pltr}) && length($sepm{$pltr}[0])); # lOdsepR8d8a
          if($shsf){push(@{$sepm{$pltr}},'') if(length( "$pfix$sfix " . sS($sepm{$pltr}[-1])) > $bwid);
            $sepm{$pltr}[-1].="$z$pfix$sfcl$sfix " if($#{$sepm{$pltr}} < 16 && length("$pfix$sfix") && length("$pfix$sfix " . sS($sepm{$pltr}[-1]))<= $bwid);}
          else     {push(@{$sepm{$pltr}},'') if(length( "$pfix "      . sS($sepm{$pltr}[-1])) > $bwid); # quik altrn8iv ckng how many prEfxz fit8blox if!sfxz
            $sepm{$pltr}[-1].="$z$pfix "           if($#{$sepm{$pltr}} < 16 && length("$pfix"     ) && length("$pfix "      . sS($sepm{$pltr}[-1]))<= $bwid);}}
        if(exists($jmap{$pltr})){$jd8a[$jmap{$pltr}]=["$Y$pltr${G}8$W:$z "] unless(defined($jd8a[$jmap{$pltr}]));
          if($#{$jd8a[$jmap{$pltr}]} <  16){my $jrnd=$#{$jd8a[$jmap{$pltr}]};         $jd8a[$jmap{$pltr}][$jrnd] ='' if(!defined($jd8a[$jmap{$pltr}][$jrnd]));
            if($shsf){ # bild 8-char blox of $bwid proly 53 wide or a bit less colmz by 16 rowz high each belo
              $jd8a[$jmap{$pltr}][++$jrnd] ='' if(length("$pfix$sfix " . sS($jd8a[$jmap{$pltr}][$jrnd])) > $bwid && @{$jd8a[$jmap{$pltr}]} <  16);
              $jd8a[$jmap{$pltr}][$jrnd].="$z$pfix$sfcl$sfix " if($jrnd <  16 && length("$pfix$sfix") && # hopefully won't space ahead for l8, r8, g8, etc.
                                                                                 length("$pfix$sfix " . sS($jd8a[$jmap{$pltr}][$jrnd])) <= $bwid);}
            else     {$jd8a[$jmap{$pltr}][++$jrnd] ='' if(length("$pfix "      . sS($jd8a[$jmap{$pltr}][$jrnd])) > $bwid && @{$jd8a[$jmap{$pltr}]} <  16);
              $jd8a[$jmap{$pltr}][$jrnd].="$z$pfix "           if($jrnd <  16 && length("$pfix") && # hopefully won't space ahead for l8, r8, g8, etc.
                                                                                 length("$pfix " . sS($jd8a[$jmap{$pltr}][$jrnd])) <= $bwid);}}}}}}
  # while I will want to tabUl8 countz for each blok PL section thN subtract from sIz grup2stRt apNdng lFtOvrz in $M,mIt try cmpUtng && squEzng in2midmap 1st?
  for   my $rndx (0..15){for my $prll (qw(t n E)){$prlt=$prll;$boff=  0; # cud frthr pRamEtrIz propag8d prOgrSn&&zOnsIzs,rthr than such manual
      if         ($prlt eq 't' &&   $rndx >=  12){$prlt=  'u';$boff= 12;}
      if         ($prlt eq 'u' &&   $rndx >=  13){$prlt=  'L';$boff= 13;}
      if         ($prlt eq 'L' &&   $rndx >=  14){$prlt=  'V';$boff= 14;}                     # special substitute 29 I8 onto end of 25 B8
      if         ($prlt eq 'V' &&   $rndx >=  15){$prlt=  'B';$boff= 15;}                     # uplt tuLVBI => 3,14,17,21,25,29
      if         ($prlt eq 'n' &&   $rndx >=  14){$prlt=  'v';$boff= 14;}                     # up   nv     => 4,11
      if         ($prlt eq 'E' &&   $rndx >=  12){$prlt=  'C';$boff= 12;}
      if         ($prlt eq 'C' &&   $rndx >=  13){$prlt=  'N';$boff= 13;}
      if         ($prlt eq 'N' &&   $rndx >=  14){$prlt=  'U';$boff= 14;}                     # special substitute 31 P8 onto end of 26 h8
      if         ($prlt eq 'U' &&   $rndx >=  15){$prlt=  'h';$boff= 15;}                     # uprt ECNUhP => 5,15,18,20,26,31
      if         ($#{$jd8a[$jmap{ $prlt}]} >= abs($rndx-$boff)){     $rosl=$bwid-length( sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)]));$rosl=0 if($rosl < 0);
        $Stxt     .= $jd8a[$jmap{ $prlt}][    abs($rndx-$boff)]   .  ' ' x $rosl;my $jltl=$bwid - $bhwd - 1; # set JoinedLineTailLength to pad blok end
        $pwsf{$prlt}+=(scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)])))+0);
        if       ($rndx ==  15){if     ($prlt eq 'B' || $prlt eq 'h'){ # could regex chars together then LUT hash $1 into shared line PLz
            if   ($prlt eq 'B'){$prlt='I';}
            elsif($prlt eq 'h'){$prlt='P';}
            $jltl= abs($jltl -     length(sS($jd8a[$jmap{$prlt}][0])));my $jlts= ' ' x $jltl;$pwsf{$prlt}+=scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][0])));
            $Stxt =~            s/\s{$bhwd}$/$jd8a[$jmap{$prlt}][0]$jlts/;}}}
      elsif      ($rndx >= $boff &&  defined($jd8a[$jmap{$prlt}][abs($rndx-$boff)])){$Stxt.=$jd8a[$jmap{$prlt}][abs($rndx-$boff)];
        $pwsf{$prlt}+=(scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)])))+0);}
      else       {$Stxt .= ' ' x  $bwid;}} $Stxt  .= "\n";}
  for   my $rndx (0..15){for my $prll (qw(l m r)){$prlt=$prll;$boff=  0; # ...mIt try cmpUtng && squEzng in2midmap 1st?
      if         ($prlt eq 'l' &&   $rndx >=  14){$prlt=  'b';$boff= 14;}                     #   lt lb     => 2,12  # sepR8 hash per PL word rendered counters
      if         ($prlt eq 'r' &&   $rndx >=  14){$prlt=  'p';$boff= 14;}                     #   rt rp     => 6,10
      if         ($#{$jd8a[$jmap{$prlt}]}>=abs($rndx-$boff) && $prlt ne 'm'){$rosl=$bwid-length(sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)]));$rosl=0 if($rosl<0);
        $Stxt     .= $jd8a[$jmap{$prlt}][  abs($rndx-$boff)]  .  ' ' x $rosl;$pwsf{$prlt}+=(scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)])))+0);}
      else{$Stxt  .= ' ' x $bwid;}
      if         ($prlt eq 'm'){$hbwd=int($bwid/2)+6     ;$stal= ' ' x  abs($hbwd- 7);
                                $hbwd=int($bwid   -4) -$s;$stal= ' ' x (abs($hbwd-(($s*($s+1))-0))-8); # lots Xtra parNz
          if     ($rndx ==  0 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${M}Precursor${Y}Letters${c}in${G}8${D}DirectnsDown${C}CloCkwise$W:${Y}clnr${o}ztEg${G}m$z   /;}
          if     ($rndx ==  2 ){$Stxt=~ s/\s{8}(\s{$hbwd})$/${z}I${R}V${C}L${M}v${C}N${R}U${z}P $1/;} # IVLvNUP
          elsif  ($rndx ==  3 ){$Stxt=~ s/\s{8}(\s{$hbwd})$/${B}B${G}u${o}t${Y}n${o}E${G}C${B}h $1/;} # ButnECh
          elsif  ($rndx ==  4 ){$Stxt=~ s/\s{8}(\s{$hbwd})$/${M}b${Y}l${K}O${r}y${K}S${Y}r${M}p $1/;} # blOySrp
          elsif  ($rndx ==  5 ){$Stxt=~ s/\s{8}(\s{$hbwd})$/${B}k${G}s${o}z${Y}c${o}g${G}m${B}x $1/;} # kszcgmx
          elsif  ($rndx ==  6 ){$Stxt=~ s/\s{8}(\s{$hbwd})$/${z}w${R}G${C}D${M}d${C}R${R}f${z}M $1/;} # wGDdRfM
          elsif  ($rndx ==  7 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${z} ${z} ${z} ${K}O${r}y${K}S${z} ${z}  $z$1/;}
          elsif  ($rndx ==  8 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${Y}c${o}z${Y}l${o}t${Y}n${o}E${Y}r${o}g $z$1/;}
          elsif  ($rndx ==  9 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${M}d${C}D${M}b${C}L${M}v${C}N${M}p${G}m $z$1/;}
          elsif  ($rndx == 10 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${R}G${G}s${R}V${G}u${R}U${G}C${R}f${C}R $z$1/;}
          elsif  ($rndx == 11 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${B}k${z}w${B}B${z}I${B}h${z}P${B}x${z}M $z$1/;}
          elsif  ($rndx == 13 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${C}L${o}t${Y}n${o}E${G}u${M}v${G}C${C}N $z$1/;} # add just2mAin dIamondz:y clnr dbvp:on botm3lInz
          elsif  ($rndx == 14 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${K}O${Y}l${r}y${Y}r${M}b${r}y${M}p${K}S $z$1/;}
          elsif  ($rndx == 15 ){$Stxt=~ s/\s{9}(\s{$hbwd})$/${C}D${o}z${Y}c${o}g${G}s${M}d${G}m${C}R $z$1/;}
          if     ($rndx ==  1 ){$Stxt=~ s/\s{$hbwd}$/$z ImpulsIveub ${C}Left   NorthNext ${z}Parry_uP$stal/;}
          elsif  ($rndx ==  2 ){$Stxt=~ s/\s{$hbwd}$/$z I$t${R}V$t${C}L$t${M}v$t${C}N$t${R}U$t${z}P$stal/;}
          elsif  ($rndx ==  3 ){$Stxt=~ s/\s{$hbwd}$/$z  ${R}VitalVect  ${M}vERSUSvERTvAPOR   ${R}UpfjUmp$z$stal/;}
          elsif  ($rndx ==  4 ){$Stxt=~ s/\s{$hbwd}$/$z ${B}BackBegin$o REtREAtOP EastEnd ${B}hEALThIGhOP$z    /;}
          elsif  ($rndx ==  5 ){$Stxt=~ s/\s{$hbwd}$/$z ${B}B$t${G}u$t${o}t$t${Y}n$t${o}E$t${G}C$t${B}h$stal/;}
          elsif  ($rndx ==  6 ){$Stxt=~ s/\s{$hbwd}$/$z   ${G}uPBJuMPuSuRP$Y nOOnORTH $G CrashCeiling$z$stal/;}
          elsif  ($rndx ==  7 ){$Stxt=~ s/\s{$hbwd}$/$z$M bACKbEFORE $K Origin  Str8Step  $M pARRYpOKE$z   /;}
          elsif  ($rndx ==  8 ){$Stxt=~ s/\s{$hbwd}$/$z$M b$t${Y}l$t${K}O$t${r}y$t${K}S$t${Y}r$t${M}p$stal/;}
          elsif  ($rndx ==  9 ){$Stxt=~ s/\s{$hbwd}$/$z   $Y lUllEFT$r NEUTRALyMyTOy$Y rIGHTrEACH  $z$stal/;}
          elsif  ($rndx == 10 ){$Stxt=~ s/\s{$hbwd}$/$z$G sHIELDsITsOUTH   $Y cROUcH$G mOUNTmIX    $z$stal/;}
          elsif  ($rndx == 11 ){$Stxt=~ s/\s{$hbwd}$/$z$B k$t${G}s$t${o}z$t${Y}c$t${o}g$t${G}m$t${B}x$stal/;}
          elsif  ($rndx == 12 ){$Stxt=~ s/\s{$hbwd}$/$z$B kEEPkNEEL  $o zESTzONE  gOgROUND  $B CRUxOL$z    /;}
          elsif  ($rndx == 13 ){$Stxt=~ s/\s{$hbwd}$/$z$R GroundGuard$M dIRECTdOWN$R fORWARDfRONT  $z$stal/;}
          elsif  ($rndx == 14 ){$Stxt=~ s/\s{$hbwd}$/$z w$t${R}G$t${C}D$t${M}d$t${C}R$t${R}f$t${z}M$stal/;}
          elsif  ($rndx == 15 ){$Stxt=~ s/\s{$hbwd}$/$z wESTw8 $C DownDefenDrop  $C Right $z MountMove$z   /;} }} $Stxt.="\n";}
  for   my $rndx (0..15){for my $prll (qw(z c g)){$prlt=$prll;$boff=  0;
      if         ($prlt eq 'g' &&   $rndx >=  6 ){$prlt=  'm';$boff=  6;}
      if         ($prlt eq 'm' &&   $rndx >= 13 ){$prlt=  'R';$boff= 13;}
      if         ($prlt eq 'R' &&   $rndx >= 14 ){$prlt=  'x';$boff= 14;}                     # special substitute 30 M8 onto end of 23 f8
      if         ($prlt eq 'x' &&   $rndx >= 15 ){$prlt=  'f';$boff= 15;}                     # dnrt gmRxfM => 7, 8,19,24,23,30  # swpd f&&x ordr2tAperoffbetr
      if         ($prlt eq 'c' &&   $rndx >= 14 ){$prlt=  'd';$boff= 14;}                     # dn   cd     => 0, 9
      if         ($prlt eq 'z' &&   $rndx >= 12 ){$prlt=  's';$boff= 12;}
      if         ($prlt eq 's' &&   $rndx >= 13 ){$prlt=  'D';$boff= 13;}
      if         ($prlt eq 'D' &&   $rndx >= 14 ){$prlt=  'G';$boff= 14;}                     # special substitute 28 w8 onto end of 27 k8
      if         ($prlt eq 'G' &&   $rndx >= 15 ){$prlt=  'k';$boff= 15;}                     # dnlt zsDGkw => 1,13,16,22,27,28
      if         ($#{$jd8a[$jmap{ $prlt}]} >= abs($rndx-$boff)){     $rosl=$bwid-length( sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)]));$rosl=0 if($rosl < 0);
        $Stxt     .= $jd8a[$jmap{ $prlt}][    abs($rndx-$boff)]   .  ' ' x $rosl;my $jltl=$bwid - $bhwd - 1; # set JoinedLineTailLength to pad blok end
        $pwsf{$prlt}+=(scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)])))+0);
        if       ($rndx ==  15){if     ($prlt eq 'f' || $prlt eq 'k'){ # could regex chars together then LUT hash $1 into shared line PLz
            if   ($prlt eq 'f'){$prlt='M';$bhwd-=4;$jltl-=4;}
            elsif($prlt eq 'k'){$prlt='w';}
            $jltl= abs($jltl -     length(sS($jd8a[$jmap{$prlt}][0])));my $jlts= ' ' x $jltl;$pwsf{$prlt}+=scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][0])));
            $Stxt =~            s/\s{$bhwd}$/$jd8a[$jmap{$prlt}][0]$jlts/;}}}
      elsif      ($rndx >= $boff &&  defined($jd8a[$jmap{$prlt}][abs($rndx-$boff)])){$Stxt.=$jd8a[$jmap{$prlt}][abs($rndx-$boff)];
        $pwsf{$prlt}+=(scalar(split(/\s+/,sS($jd8a[$jmap{$prlt}][abs($rndx-$boff)])))+0);} # 'm' off by 2 so maybe hackfix 2 just add xtraz below2compNs8?
      else       {$Stxt .= ' ' x  $bwid;}} $Stxt  .= "\n";} my $ltot=0;for my $splz (split(//,'bcdfghklmprswmm')){$pwsf{$splz}++;} # shOlFtwrdcntzaftrmap4now
  $Stxt.="${C}Remaining$B Left${o}Over$M Pre${Y}Letter$R Counts$z:  ";my %lowc; # setup reverse hash to preserve Left Over Word Countz of pdifz 2 sort by l8r
  for   my $tmpl (sort(keys(%pwsf))){$pwsf{$tmpl}--;my $pdif=$lcnt[ b10($tmpl)] - $pwsf{$tmpl};
    if($pdif){$ltot+=$pdif+1;$lowc{$pdif}.=$tmpl;}}#$Stxt.="$Y$tmpl$W:" . # sEmzlIk 1012/1369 wrdz prntd so far && matchz curNtly calQl8d rsltz
  for   my $locv (sort {$a <=> $b} keys(%lowc)){ # now these loopz shud reordr by left over countz ascending nstd of alpha
    for my $tmpl (sort(split(//,$lowc{$locv}))){$Stxt.=sprintf("$Y$tmpl$W:$M%d ",$locv);}} $Stxt.="  ${R}$t0tl $Y- $o$ltot $G= $B" . ($t0tl-$ltot);
  $Stxt.=sprintf("$M %8.3f$C%%$K shown$W;\n$z",(($t0tl-$ltot)*100.0/$t0tl)); # try to wrap up total map printing with percentage shown in single page
  $Stxt=sS($Stxt) unless($clrf || $Stxt eq 'h');$Smap=$Stxt;$Stxt=''; # 1pAg map curNtly listz about 1009/1369 = ~73.7% of tOtl 8-wordz now shOwn @once;
        o8($Smap)     if($pg1f); # slightly repurpose the -p single Page option flag to show the -g 1-page map when gener8d rathr than Dflt @end,sinc focal;
  # maybe since most prefixes are longer also altern8 inward from both ends preferring more total chars culled for wider from top 8 solos or some thresh?
  # ..or actually resummarize all above thoughts to 1st prime 2 given to suffix outside-in R2L for ion then 2nd 3 given to permanently termin8 any further
  #   attempts to altern8 for now known complete suffix for almost 94% of all words, then try biggest in L2R altern8 out for prefixes until all accounted
  # findng Specialy EficiNt permut8ions sEms daunting2preserve so much progress st8 for just multiple size strings before even delving to next or ultim8 best
  # ..&& by metrics of max composite plus some accounting for average offered too? think of betr d8astructz4sizng matching blockz && fix Pre/Suf Out/In ordr.
  # maybe when working, can lead to varE8ion for encoding most typical syllable pronunC8ion references then visual multiple assoC8ions && explore clustering;
  $mxws=  5 if($pg1f); # then mv 8p.ls 8pc.ls && start new 8ps.ls for Octology8 Prime Components or Side Strings (with _ empty right start 1st as 881 2z again)
  $Stxt=~ s/\n?$/\n/;for my $wsiz (2..$mxws){my @folk=sort(keys(%{$folc[$wsiz]}));my @fola=();$Stxt.=$G; # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    my $stcz=int($clmz / 6); # normal initial alignments are 5 characters plus space, which should normally fit original 26 word columns within 160 char colmz
    if($wsiz == 2){$Stxt.="${W}Only 2z fit with preceding lines of b8 (2 4095), products only also fit 3z, otherz should fit sums && averages (B4nw2ad).\n$B";
      for my $fndx (0..$#folk){my $b10w=b10($folk[$fndx]);$Stxt.=sprintf(" %5d"      ,$b10w);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$M";
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$C";}
    if($wsiz == 3){                                                                                                                  $Stxt.=   $M ;
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n"  ;}
    if($wsiz <= 5){                                                                                                                  $Stxt.=   $C ;
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %5d"        ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $fstr =sprintf(" %2.2f"      ,$fola[$fndx]);$fstr=~ s/(\.?0+)$/$r$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%5s" ,b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz aligned with other numb repz
                                                                              $Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.="$z ".' ' x (5 - length($folk[$fndx]));my $slbv;for my $nxtc (split(//,$folk[$fndx])){if($nxtc=~ /^[0-9A-Z._]$/i){
            if(defined($slbv)){if($slbv > b10($nxtc)){$Stxt.=$z.$B;}else{$Stxt.=S('Mb');} $Stxt.=b64(abs($slbv - b10($nxtc)));$slbv=b10($nxtc);} # EchUniq2!
            else              {   $slbv = b10($nxtc); $Stxt.=$z.$nxtc;}}}   $Stxt.="$z\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z"; # shOz dLtaz off prEv b64
      for my $fndx (0..$#folk){my $foln =sprintf(" %5s"        ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g; # valid PLz
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n";}
    elsif(scalar(@folk)){      my $wrdw=int($clmz / ($wsiz+1) );$Stxt.=$C; # skip over empty 18z
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %${wsiz}s"  ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $frsz =$wsiz-3; # mAB special cAs 8 2fit just %2.3f or mk trail zer0z dRk red nstd?
                               my $fstr =sprintf(" %2.${frsz}f",$fola[$fndx]);$fstr=~ s/(\.?0+)$/$k$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%${wsiz}s",b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz
                                                                              $Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){$Stxt.="$z ".' ' x ($wsiz - length($folk[$fndx]));my $slbv;for my $nxtc (split(//,$folk[$fndx])){if($nxtc=~ /^[0-9A-Z._]$/i){
            if(defined($slbv)){if($slbv > b10($nxtc)){$Stxt.=$z.$B;}else{$Stxt.=S('Mb');} $Stxt.=b64(abs($slbv - b10($nxtc)));$slbv=b10($nxtc);}
            else              {   $slbv = b10($nxtc); $Stxt.=$z.$nxtc;}}}   $Stxt.="$z\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){my $foln =sprintf(" %${wsiz}s"  ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n";}
# try2loop avrgz abov nstd but mA nEd special wrapz dn from 26 B4 6 to 6:22, 7:20, 8:17, ... shud B formUla or Dtectabl
# old notez4wsiz 2: this is probably more useful mean average summariez && think of prime factorz or othr wayz to represent mostly unique partz
#                5: try to cut 2 (or 6 if adding 4 N8 varE8ionz bakin) to get 5z dn2 3rd rel8ively clean concise set of 96 to make another sumb page out of
  } $Stxt.="${C}cuts$W:$Y 2$W:${G}N8 $o(${K}b8 c8 d8 g8 w8$o)$Y  3$W:${G}DN8$Y  4$W:${G}NfN8 SSN8 $o(${K}ckm8 pal8 upd8$o)$Y  5$W:${G}m8rix coll8$Y";
    $Stxt.="$Y  6$W:${G}?$Y  7$W:${G}?$Y ...\n"; # hopefully above -g will align a b10 line over b64 lines
  # try new small set of sequential prime number alloc8ions && then multiply recurring subset primes then try to refactor && reconstruct from gr8st down
  # I3QMIGHT:now 128 (2=>9,3=>34,4=>85) entries left after above cuts,but may want to splice more drastically down 32 more to top 96ish for next bin sumb page;
  $folc[2]{ 'N8'}=$folc[2]{  'b8'}=$folc[2]{  'c8'}=$folc[2]{  'd8'}=$folc[2]{  'g8'}=$folc[2]{  'w8'}=1;
  $folc[3]{'DN8'}=$folc[4]{'NfN8'}=$folc[4]{'SSN8'}=$folc[4]{'ckm8'}=$folc[4]{'pal8'}=$folc[4]{'upd8'}=1;
  $folc[5]{'m8rix'}=$folc[5]{'coll8'}=1; # need to try to put cuts back in so PL counts can match again
}   # maybe multiplying && factoring primes as essentially bit-flags requiring escal8ing order to build words to according to growing wsiz ordr is inefficient
    #   && still indirect, but mAB less useful than srchng whole word-set entirely to build all at once deliber8ly right-to-left wi prioritized substringz?
$Stxt=sS($Stxt) unless($clrf);o8($Stxt);$Stxt ='';
if($fulf){$Stxt=~ s/\n?$/\n/;my %cvlz=reverse(%fulc);my @ccnt= sort { $a <=> $b } keys(%cvlz);my $jus8=0;my $sumn=0; # 2colmzof fulcntz fitznIc undr50lInz sOfR
  for     my $cndx (0..$#ccnt){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    for   my $char (sort(keys(%fulc))){ # this now is intended to be just a single linear column which duplic8z the content of the orig 2-columnz below
      if    ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(|||\n)$/); # special count for only double-wide characters
        $sumn      +=  $coun                    if($char=~ /^[0-79]$/       ); # special sum of Non-8 digits to compare at end
        $jus8       =  $coun                    if($char=~ /^8$/            ); # special just       8        to compare at end
        $w82o      .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
    } # $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,$z    %4d$B;\n",cma($coun),b8colr(sprintf("%4s",b64($coun))),$cndx); 
  }   # $Stxt.="\n"; # just disabling now redundant double-long single column full counts list output, but still keeping the 8 vs. other digit counts
  for     my $cndx (0..int($#ccnt/2 )){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    if($cndx < int($#ccnt/2)+1){ # +1 was abov with @ccnt nstd of $#ccnt && originally had the +1 inside the int() call here
      for my $char (sort(keys(%fulc))){ # then above CharCouniNDeX loops just unique counts && (was Probably) PrintCouNT before Wait to Output8
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(|||\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
      } $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,",cma($coun),b8colr(sprintf("%4s",b64($coun))));
    } $coun=$ccnt[int($#ccnt/2)+$cndx+1];                       $pcnt=0;   $w82o=''; # restore conditions for always 2nd column for now (ad optn l8r)
    if(defined($coun)){ # odd number of chars may leave last invalid coun so check   # abov hook used to be ?1:0 but now testing whether necessary
      for my $char (sort(keys(%fulc))){ # no longer trying to sum non-8 digitz during 2-column printing down here, doing it once during the single column abov
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(|||\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # belo was once trying some random colrz with: ,S(substr($cmap{'d8bo'},b64(int(rand(8))),1)));
      } $Stxt.=sprintf((' ' x ( 8-$pcnt))."$C$w82o$B:$M".sprintf("%7s$B: %s$W,\n",cma($coun),b8colr(sprintf("%4s",b64($coun)))));
    } } $Stxt.=sprintf("$C  Sum of$B: ${G}0$W..${G}7$W,${G}9$B: $M%s$o      dif$Y:$B%7s$W;$z",cma($sumn),cma($jus8-$sumn));}
$Stxt=sS($Stxt) unless($clrf);o8($Stxt);o8("\n$Smap") if($gm8f && defined($Smap) && length($Smap) && !$pg1f);

# 2du:gener8 all entries below into new d8a-struct && sepR8 ones for *t8(ion)? && *E8 as *iat(e|ion) ends, to then compare against loc8d 8-words 4 diffz 2add;
#   rel8ively few results just for *z8 end... then maybe all these should load into hashes to match against l8st presently defined 8.txt 8-words 2sync or add;
my   @dz8_=(sort(qw(Albizz8 Baranz8 Costa_di_Mezz8 Istituto_Europeo_Studi_Tecnologie_Avanz8 Ouarzaz8_Morocco_-_Ouarzaz8 Solemniz8 Valdez8 Alkaliz8 Cadrezz8
  Dialyz8 Lazz8 Patriz8 solmiz8 vulcaniz8 Associazione_Ticinese_Truppe_Motorizz8 Ceniz8 Engineering_Thermoplastic_Vulcaniz8 Mozz8 Preconiz8 Ouarzaz8 Trapez8
  Thermoplastic_Vulcaniz8 Zelz8 autolyz8 Centro_Studi_e_Applicazioni_in_Tecnologie_Avanz8 Guanz8 Nz8 pyrolyz8 Torricella_Verz8 Azz8 Colz8 hydrolyz8 reduz8)));
#  there were more than 200 results which were trunc8d from *z8ion ending
my   @dz8n=(sort(qw(animaliz8ion Antiglobaliz8ion arterializ8ion Brachycephaliz8ion centrifugaliz8ion constitutionaliz8ion Cyborgiz8ion decriminaliz8ion
  dematerializ8ion depoliticiz8ion devocaliz8ion editorializ8ion epithelializ8ion Fetishiz8ion fluidiz8ion Franciz8ion Glocaliz8ion Hiberniciz8ion
  idealiz8ion internationaliz8ion Judaiz8ion localiz8ion medicaliz8ion misvocaliz8ion Neologiz8ion Operationaliz8ion patrializ8ion philosophiz8ion
  plasticiz8ion procliticiz8ion racializ8ion recanaliz8ion Resocializ8ion self-realiz8ion signaliz8ion specializ8ion subvocaliz8ion theologiz8ion
  tropicaliz8ion Aggrandiz8ion anodiz8ion Antimondializ8ion Backwardiz8ion canaliz8ion cephaliz8ion conventionaliz8ion de-angliciz8ion Deindusrtializ8ion
  Democraticiz8ion deradicaliz8ion diagonaliz8ion emotionaliz8ion eroticiz8ion feudaliz8ion fluoridiz8ion Gaeliciz8ion God-realiz8ion hierarchiz8ion
  illegaliz8ion iodiz8ion labializ8ion marbleiz8ion memorializ8ion musicaliz8ion Nitridiz8ion optimaliz8ion penaliz8ion phonemiciz8ion politicaliz8ion
  professionaliz8ion radializ8ion regionaliz8ion romanticiz8ion Selfrealiz8ion Siniciz8ion Spheroidiz8ion syllogiz8ion Thermaliz8ion vandaliz8ion
  alkaliz8ion anthologiz8ion Appleiz8ion banaliz8ion cannibaliz8ion cliticiz8ion Copy-initializ8ion de-energiz8ion deindustrializ8ion demythologiz8ion
  derealiz8ion diphthongiz8ion Encephaliz8ion etherealiz8ion fictionaliz8ion focaliz8ion Galliciz8ion grammaticaliz8ion Hispaniciz8ion industrializ8ion
  iridiz8ion laiciz8ion marginaliz8ion mercurializ8ion mythiciz8ion nomadiz8ion Orthonormaliz8ion Periodiz8ion phoneticiz8ion politiciz8ion pronominaliz8ion
  radicaliz8ion reindustrializ8ion ruggediz8ion sensationaliz8ion socializ8ion standardiz8ion tabloidiz8ion topicaliz8ion verbaliz8ion Anarchiz8ion
  anthropomorphiz8ion Arabiciz8ion bastardiz8ion catechiz8ion commercializ8ion corticaliz8ion Debuccaliz8ion deinstitutionaliz8ion denationaliz8ion
  Deserializ8ion Direct-initializ8ion encliticiz8ion fanaticiz8ion finaliz8ion formaliz8ion gleiz8ion Haploidiz8ion historiciz8ion initializ8ion
  Islamiciz8ion legaliz8ion marsupializ8ion methodiz8ion mythologiz8ion Nominaliz8ion overspecializ8ion personaliz8ion physicaliz8ion potentializ8ion
  provincializ8ion rationaliz8ion Renationaliz8ion scandaliz8ion serializ8ion spacializ8ion subsidiz8ion territorializ8ion tribaliz8ion Villagiz8ion
  Angliciz8ion Anti-globaliz8ion Arabiz8ion bestializ8ion catholiciz8ion conditionaliz8ion criminaliz8ion decimaliz8ion delocaliz8ion deoxidiz8ion
  detribaliz8ion dockiz8ion energiz8ion faradiz8ion Finlandiz8ion fractionaliz8ion globaliz8ion Hebraiz8ion hybridiz8ion institutionaliz8ion
  italiciz8ion lexicaliz8ion materializ8ion minimaliz8ion nationaliz8ion normaliz8ion oxidiz8ion Pharyngealiz8ion pictorializ8ion Pro-globaliz8ion
  publiciz8ion realiz8ion renormaliz8ion sectionaliz8ion sherardiz8ion Spatializ8ion subspecializ8ion theatricaliz8ion trivializ8ion vocaliz8ion
  monopoliz8ion schematiz8ion systematiz8ion))); # last 3 here didn't make the first 200 cut
#  had to run sepR8 *meriz8ion end to get following list but may still need to rediscover correct HTTPS://En.WikiPedia.Org/wiki/Microtubule page of varE8ions
push(@dz8n, sort(qw(Addition_polymeriz8ion Atom-transfer_radical-polymeriz8ion catalytic_polymeriz8ion Cobalt-MeD8d_Catalytic_Chain-Transfer_Polymeriz8ion
  copolymeriz8ion Depolymeriz8ion Epimeriz8ion isomeriz8ion Living_polymeriz8ion oligomeriz8ion photodimeriz8ion polymeriz8ion Ring_opening_polymeriz8ion
  Solution_polymeriz8ion Tautomeriz8ion Trans-cis_isomeriz8ion Anionic_addition_polymeriz8ion autopolymeriz8ion cationic_polymeriz8ion cold-cure_polymeriz8ion
  cross_polymeriz8ion Dimeriz8ion Hazardous_polymeriz8ion IT_consumeriz8ion mesmeriz8ion Organometallic_Catalysts_and_Olefin_Polymeriz8ion
  photoinitE8d_polymeriz8ion RaD8ion-Induced_Graft_Polymeriz8ion Ring-opening_metathesis_polymeriz8ion Stable_Free_Radical_Polymeriz8ion telomeriz8ion
  vinyl_polymeriz8ion anionic_polymeriz8ion butane_vapor-phase_isomeriz8ion Cationic_Ring-Opening_Polymeriz8ion Condens8ion_polymeriz8ion
  cross-linked_polymeriz8ion Emulsion_polymeriz8ion Heterodimeriz8ion Leveling-Off_Degree_of_Polymeriz8ion Microwave-Assisted_Ring-Opening_Polymeriz8ion
  Organometallic-MeD8d_Radical_Polymeriz8ion Photoisomeriz8ion Radical_polymeriz8ion Ring-opening_polymeriz8ion Step-growth_polymeriz8ion
  Thermal_depolymeriz8ion Anomeriz8ion California_polymeriz8ion Chain-growth_polymeriz8ion consumeriz8ion Customeriz8ion Enzymatic_Ring-Opening_Polymeriz8ion
  Homodimeriz8ion light_polymeriz8ion Nitroxide-MeD8d_Radical_Polymeriz8ion phosphoric_acid_polymeriz8ion Photopolymeriz8ion
  Reversible_addition-fragment8ion_chain-transfer_polymeriz8ion RNA-dependent_DNA_polymeriz8ion Stereospecific_Polymeriz8ion thermal_polymeriz8ion
  Atom_Transfer_Radical_Polymeriz8ion Catalytic_depolymeriz8ion Cis/trans_isomeriz8ion Coordin8ion_polymeriz8ion Degree_of_polymeriz8ion enzyme_isomeriz8ion
  ionic_polymeriz8ion Living_Anionic_Surface_InitE8d_Polymeriz8ion Olefin_polymeriz8ion photo_polymeriz8ion Plasma_polymeriz8ion
  Ring_Opening_Multibranching_Polymeriz8ion selective_polymeriz8ion Suspension_polymeriz8ion Thymine_dimeriz8ion)));
my   @do8n=(sort(qw(Detyrosin8ion Acetyl8ion Polyglutamyl8ion Polyglycyl8ion phosphoryl8d ubiquitin8d sumoyl8d palmitoyl8d)));
#  looks like HTTPS://En.WikiPedia.Org/wiki/Oligomer contains the original details I extrapol8d into:
push(@dz8n, sort(qw(homomeriz8ion heteromeriz8ion monomeriz8ion dimeriz8ion trimeriz8ion tetrameriz8ion oligomeriz8ion polymeriz8ion telomeriz8ion)));
#  where above homo && hetero may be able to precede any of the others && further examin8ion of the text loc8d additional: first 200 *iate:
my   @dE8_=(sort(qw(affilE8 antlE8 ascidE8 benficE8 BiradE8 calumnE8 CompendE8 ContornE8 cranE8 DebullE8 deprecE8 DimidE8 DisintermedE8 EffigE8 EradE8
  ExpedE8 folE8 glacE8 HeteroganglE8 IndulgE8 InodE8 InterfolE8 LamellibranchE8 LophobranchE8 microsporangE8 negocE8 nudibranchE8 pallE8 PerennibranchE8
  precollegE8 PulmonibranchE8 remedE8 retalE8 SinupallE8 specE8 SuperbE8 TrachelobranchE8 UnE8 vicarE8 abranchE8 AmplE8 apprecE8 AsperifolE8 bifolE8
  brachE8 capacE8 concilE8 ContournE8 crucE8 defolE8 DermobranchE8 disaffilE8 dissocE8 ElasmobranchE8 ErudE8 expE8 ForisfamilE8 gladE8 HinnE8 InexpE8
  InsanE8 intermedE8 LanE8 LycopodE8 minE8 noncollegE8 NuncE8 PalliobranchE8 perfolE8 PremedE8 quadrifolE8 renegocE8 ScammonE8 SiphonobranchE8 SpolE8
  taenE8 TranspecE8 UnibranchE8 VicE8 AbsinthE8 AngustifolE8 archegonE8 assocE8 bilabE8 branchE8 CarE8 ConglacE8 ConvicE8 CryptobranchE8 DelicE8 dibranchE8
  DisapprecE8 domicilE8 emacE8 eusporangE8 fascE8 FormE8 glochidE8 HomoganglE8 InferobranchE8 InsidE8 irradE8 LatifolE8 MaleficE8 misapprecE8 NotobranchE8
  officE8 parvifolE8 petechE8 PrimordE8 quinquefolE8 RenuncE8 ScutibranchE8 SocE8 StipendE8 tallE8 trifolE8 unifolE8 VindemE8 AcutifolE8 annuncE8 arpeggE8
  AuriphrygE8 BilacinE8 breccE8 cilE8 Connate-perfolE8 CorradE8 curvifolE8 Dentate-cilE8 DigladE8 disassocE8 DorsibranchE8 EmollE8 excrucE8 fastigE8
  free-assocE8 hellgrammE8 humilE8 InfolE8 InsocE8 labE8 leptosporangE8 marsupE8 multifolE8 novicE8 OpinE8 patricE8 photodissocE8 ProvincE8 radE8 repudE8
  Serr8-cilE8 somnE8 subcollegE8 TectibranchE8 TripudE8 UnifollE8 x-irradE8 AdversifolE8 antimonE8 ArsenE8 beneficE8 BinarsenE8 CaducibranchE8 collegE8
  consocE8 CorrodE8 CyclobranchE8 DenuncE8 DilanE8 DiscrucE8 EbullE8 enuncE8 exfolE8 filE8 ganglE8 hernE8 immedE8 IngenE8 intercollegE8 lacinE8 LicencE8
  medE8 MultiradE8 NudibrachE8 OpisthobranchE8 PectinibranchE8 postcollegE8 pulmobranchE8 ReassocE8 reradE8 SexradE8 SoredE8 SubtilE8 tetrabranchE8
  TriradE8 UnilabE8 ZygobranchE8))); # first 200 *iation
my   @dE8n=(sort(qw(abbrevE8ion alluvE8ion AnnihilE8ion approprE8ion avE8ion blovE8ion cheluvE8ion columnE8ion consubstantE8ion DefilE8ion denuncE8ion
  DigladE8ion DisapproprE8ion EffigE8ion EradE8ion exodevE8ion exponentE8ion FerE8ion folE8ion GlorE8ion illuvE8ion infurE8ion InstancE8ion IrreconcilE8ion
  lixivE8ion minE8ion negotE8ion pallE8ion PE8ion PrefolE8ion PrincipE8ion ProunouncE8ion ReapproprE8ion renegotE8ion retalE8ion SerE8ion strE8ion
  TalE8ion unapprecE8ion vitE8ion AbrenuncE8ion ammonE8ion annuncE8ion ArpeggE8ion beneficE8ion brachE8ion chemexfolE8ion concilE8ion CorradE8ion
  defolE8ion deprecE8ion DilanE8ion disassocE8ion elutrE8ion esodevE8ion expatE8ion exproprE8ion filE8ion ForisfamilE8ion hernE8ion ImproprE8ion
  ingratE8ion instantE8ion lacinE8ion LuxurE8ion misapprecE8ion Non-repudE8ion PatrE8ion pilE8ion preinitE8ion PrononcE8ion racE8ion reconcilE8ion
  renuncE8ion satE8ion SocE8ion subassocE8ion TranssubstantE8ion undifferentE8ion x-irradE8ion AdfilE8ion AmplE8ion AntidifferentE8ion AsphixE8ion
  BilE8ion breccE8ion cilE8ion ConglacE8ion covarE8ion DeforcE8ion despolE8ion DimidE8ion disintermedE8ion eluvE8ion excorE8ion expatrE8ion ExspolE8ion
  fimbrE8ion Free-assocE8ion HE8ion InanitE8ion InhE8ion intercolumnE8ion LanE8ion MaleficE8ion misapproprE8ion ObrivE8ion perfolE8ion postirradE8ion
  prenegotE8ion PronouncE8ion radE8ion redifferentE8ion repatrE8ion self-deprecE8ion specE8ion substantE8ion transubstantE8ion UnsubstantE8ion X-radE8ion
  affilE8ion AngarE8ion antidisintermedE8ion asphyxE8ion bioremedE8ion calumnE8ion circumstantE8ion consocE8ion CrucE8ion deglacE8ion devE8ion DiradE8ion
  dissocE8ion emacE8ion excrucE8ion expE8ion exuvE8ion FlorE8ion FrE8ion humilE8ion InapprecE8ion initE8ion intermedE8ion licentE8ion MaterE8ion
  MispronouncE8ion obvE8ion PhotodissocE8ion potentE8ion PrenuncE8ion pronuncE8ion re-intermedE8ion ReintermedE8ion repudE8ion self-dissocE8ion
  spolE8ion SupercolumnE8ion TripudE8ion varE8ion zone of eluvE8ion allevE8ion AnnhilE8ion apprecE8ion assocE8ion bisocE8ion centurE8ion ColluvE8ion
  ConsopE8ion dedifferentE8ion DeliquE8ion differentE8ion disaffilE8ion domicilE8ion enuncE8ion exfolE8ion ExpolE8ion fascE8ion fluvE8ion glacE8ion
  HydroavE8ion inebrE8ion innidE8ion irradE8ion List_of_botanists_by_author_abbrevE8ion medE8ion mispronuncE8ion officE8ion phytoremedE8ion PraefolE8ion
  PrestigE8ion propitE8ion reaffilE8ion remedE8ion reradE8ion self-renuncE8ion storE8ion SuperfolE8ion tritE8ion VindemE8ion zone_of_illuvE8ion))); # 1st200*t8
my   @dt8_=(sort(qw(Abirrit8 ambident8 Archont8 benzonat8 Butylacet8 Chloroacet8 comment8 Curvident8 decrepit8 dent8 digit8 edent8 Eluct8 Exagit8 Expedit8
  Febricit8 fragment8 Hect8 imit8 Indubit8 instrument8 jactit8 Limit8 met8 multident8 nictit8 Oblect8 Overagit8 Paridigit8 placent8 Pregravit8 quantit8
  redict8 Result8 Saccholact8 Serrate-dent8 Stabilit8 Suscit8 tract8 Tripalmit8 ablact8 amphident8 Ariet8 bident8 CANt8 Circumagit8 Counterirrit8 debilit8
  Deit8 Dequantit8 Discapacit8 Edet8 eruct8 Exalt8 Exsuscit8 felicit8 Front8 hesit8 Imparidigit8 Inequit8 Interdigit8 Kaopect8 Lubricit8 Methylacet8
  Multidigit8 Nippit8 Octodent8 oxalacet8 pect8 potent8 premedit8 Quinquedent8 regurgit8 resuscit8 salt8 simplicident8 stipit8 Sustent8 Tri-acet8
  Tubulident8 acet8 Amyl-acet8 Ashton-t8 Bidigit8 capacit8 coarct8 crepit8 Decant8 Delect8 dict8 Dishabilit8 Efflagit8 Ethylacet8 Excit8 Exuscit8
  Fertilit8 gravit8 Hospit8 Impunct8 infinit8 interpret8 lact8 Mannit8 methylprednisolone-21-dimethylaminoacet8 mussit8 Nobilit8 orient8 oxaloacet8 pelt8
  precipit8 punct8 quinquedigit8 rehabilit8 Retract8 sanit8 Solicit8 Subacet8 t8 triacet8 veget8 acetoacet8 ancipit8 Attent8 Bipelt8 capit8 cogit8 Cruent8
  decapit8 delimit8 Difficilit8 disorient8 egurgit8 Ethylenediaminetetraacet8 excogit8 facilit8 Flagit8 habilit8 humect8 incapacit8 ingurgit8 Inusit8
  Latident8 medit8 milit8 necessit8 Norit8 Oscit8 palmit8 Periclit8 Precogit8 Quadrident8 Ratit8 Reluct8 Retrct8 sediment8 spect8 superfet8 Tolnaft8
  trident8 Vendit8 agit8 Angulo-dent8 auscult8 Bipunct8 cavit8 cohabit8 cryoprecipit8 Decemdent8 Dement8 Difficult8 Dubit8 Elicit8 Evit8 Exorbit8 Farct8
  Fluoroacet8 hebet8 Imbecilit8 Indigit8 Inhabit8 irrit8 levit8 Mellit8 multicapit8 nict8 Obequit8 ostent8 palpit8 pernoct8 predent8 quadridigit8
  Recapacit8 reorient8 reveget8 segment8 Squarroso-dent8 Suppedit8 tomt8 tridigit8 volit8))); # first 200 *tation
my   @dt8n=(sort(qw(abirrit8ion affect8ion Attrect8ion capit8ion Co-habit8ion Coimmunoprecipit8ion crepit8ion decrepit8ion deposit8ion dishabilit8ion
  Eluct8ion eruct8ion excogit8ion expedit8ion Fet8ion fugit8ion hebet8ion immunoprecipit8ion Inexpect8ion Insanit8ion Inusit8ion labefact8ion limit8ion
  milit8ion multifet8ion nictit8ion Obluct8ion overexploit8ion Pernoct8ion Preexpect8ion Propitit8ion recit8ion Resucit8ion revisit8ion Self-exalt8ion
  Solvat8ion superfet8ion Suscit8ion Trit8ion veget8ion ablact8ion agit8ion Blacksploit8ion Carbonat8ion Co-immunoprecipit8ion Colluct8ion cunct8ion
  Delact8ion Devit8ion disinvit8ion Enat8ion Evit8ion exercit8ion exploit8ion Flagit8ion gravit8ion hesit8ion Inaffect8ion ingraft8ion Insect8ion
  invit8ion lact8ion Luct8ion Miscit8ion mussit8ion Nobilit8ion Obtrect8ion palpit8ion Photoexcit8ion premedit8ion punct8ion regurgit8ion resuscit8ion
  Ruct8ion self-limit8ion Spect8ion Superfoet8ion Tardit8ion Unexpect8ion Velit8ion Acclimat8ion Allect8ion blaxploit8ion Castramet8ion coarct8ion
  Concit8ion debilit8ion delect8ion dict8ion Dit8ion Engraft8ion Exagit8ion Exfet8ion Exsuscit8ion float8ion gurgit8ion Humect8ion incapacit8ion
  ingurgit8ion interdigit8ion irrit8ion Latit8ion Mact8ion misinterpret8ion nat8ion nonexploit8ion occult8ion pelt8ion Pollicit8ion Presdigit8ion
  quantit8ion rehabilit8ion Resussit8ion salt8ion sexploit8ion strepit8ion Supernat8ion Tract8ion unpremedit8ion Vendit8ion accredit8ion arct8ion
  bronchodilat8ion cavit8ion cogit8ion constat8ion decapacit8ion delimit8ion digit8ion Dubit8ion equit8ion exalt8ion Exheredit8ion facilit8ion
  floccit8ion habilit8ion Illimit8ion incit8ion inhabit8ion interpret8ion jact8ion levit8ion medit8ion Mislact8ion necessit8ion Nonlimit8ion Oscit8ion
  perfect8ion precipit8ion Prestadigit8ion Quirit8ion reinterpret8ion retract8ion sanit8ion silt8ion Subagit8ion Supparasit8ion Transfret8ion vasodilat8ion
  visit8ion addubit8ion Ariet8ion capacit8ion Cit8ion cohabit8ion counterirrit8ion decapit8ion Deploit8ion dilat8ion elicit8ion Erruct8ion excit8ion
  expect8ion felicit8ion Foet8ion habit8ion imit8ion Indigit8ion Inquiet8ion intervisit8ion jactit8ion Licit8ion Mdit8ion Morsit8ion nict8ion Oblect8ion
  overexpect8ion Periclit8ion Precogit8ion prestidigit8ion reaccredit8ion Reluct8ion reveget8ion Sciscit8ion solicit8ion Superexalt8ion Suppedit8ion
  Transnat8ion Vectit8ion volit8ion)));
