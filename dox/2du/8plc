#!/usr/bin/perl
# D6OMHm3L:8plc crE8d to read PipStuart's <Pip@CPAN.Org> 8.txt (mainly 2 specific columns) to tabul8 && print the 8 Precursor Letter Counts;
# 2du:Dtect nstd of hRdcOd 16th colm,add dur8z around sectnz&&mAB try2optimIz per4manc of slOSt pRtz(tkz about 12-18secs for basic to -all),
#   4 -g:try reloopng 4 Ech singl rOw alInmNtz nstd of init blox,fix all -p pg1f to count up to actual linz rather than hardcode 160x48 limitz,
#   4 -g gM8ria:try2add sumz,productz,modez,meanz,medianz,cnsidr delta difz&&r8ioz,prIm factrz,add colrz,graph rangez,iconz,contMpl8 othr good posibl repz,
#   mk sepR8 tabul8ion of 8-words used in l8r document8ion wi not8ion 4thOs not yet included in top lists (thN optn2ignor easy conjug8ions && pre/suffixes),
#   mk easy optn4 fulc 2use 1colm 4grep,add 4m@d percNtz,stuD wc && mk a8:cnt8/8c wi fulc -f? && 8plc as -l? optnz(rEdo hedrtXt),colr letrz,add f0ntz4 8trm;
use strict;use warnings;use utf8;use v5.10;use Octology::a8;use Octology::b8;
my $d8VS='I3PMLETR';       my $clrf=1;my $fulf=0;my $argz='';$argz= join(' ',@ARGV) if(@ARGV);my $Stxt='';my $folf=0; # add 4-Or-Less-Flag
my $edVS=        '';       my $pg1f=0;   $pg1f=1 if($argz=~ /(^|\s)-?-?[^p]*p/i); # find -?p(age) flag2limit some extra long output to first 48-line page
my $mxws=        19;       my $lpsf=0;   $lpsf=1 if($argz=~ /(^|\s)-?-?[^l]*l/i); # find -?LetrPrecursShortsFlag  # if MaXWordSize evr grOz,wil nEd2incrEs|Dtct
my $clmz=        80;       my $gm8f=0;   $gm8f=1 if($argz=~ /(^|\s)-?-?[^g]*g/i); # find -?g(m8r) flag2count&&adorn wi math 4mUl8ions stRting wi 2letr
my $linz=        24;       my %fulc=();  $fulf=1 if($argz=~ /(^|\s)-?-?[^f]*f/i); # find -?f(ull) flag to count && sort all         characters at end
                           my @folc=();  $folf=1 if($argz=~ /(^|\s)-?-?[^w]*w/i); # find -?w(ord) flag to count && sort all maximum char-words at end
                           my %lpsd=();  $clrf=0 if($argz=~ /(^|\s)-?-?[^s]*s/i); # find -?s(SKp) flag arg4vim ':r!8plc s' 2B lIk ':r!8plc|sS'
$clmz=$ENV{'COLUMNS'} if(exists($ENV{'COLUMNS'})); # mAB also Dtect H varE8ionz
$linz=$ENV{'LINES'  } if(exists($ENV{'LINES'  }));my $lnmx=$linz - 2;
if($argz=~ /(^|\s)-?-?[^a]*a/i){   $lpsf=$gm8f=$fulf=$folf=1;} # set All optional section flags at once
if($argz=~ /(^|\s)-?-?[^h]*h/i){$Stxt.=" $0 - 8.txt Precursor Letter Counter d8VS:$d8VS by $auth to gener8 Octology applic8ion name d8a analysis;
  h   - print this Help text and exit; below options are flags which can be combined in any order, but extra sections print in order of comput8ion;
  s   - print below options as just plain text (Strip default eScape color codes, like running `$0 | sS` post-process);
  p   - print below options as limited to just first $lnmx-line Page instead of default everything (fixed 160x50 single Pages work for -l -w -g);
  a   - print All extra options below (like calling `$0 lwgf`)   (with -p limiting almost all sections to just 1 160x50 Page of output for each);
  l   - print Letters of precursors sorted by size                 (with -p only printing up to z 102 and cutting off before c 131 as 1 Page);
  w   - print Words sorted by size up to current maximum of $mxws     (with -p only printing from 2 to  9 for just first $lnmx-line Page);
  g   - print gM8ria 'Gematria' word valU8ions in aligned sections as preliminary trial of a few short approaches to some numerology;
  f   - print Full character counts (maybe l8r extracted to a8:cnt8 and `8c` like `wc`);";
  if(20 < $clmz && $clmz < 160){my @htxt=split(/\n/,$Stxt);$Stxt='';my $lsiz;my $tokn;for(@htxt){$lsiz=0;while(s/^(\s*\S+)//){$tokn=$1; # smRt split Help tXt
        if($lsiz + length($tokn) > $clmz){$Stxt.="\n" . (' ' x 8);$lsiz=8;$tokn=~ s/^\s+//;} $Stxt.=$tokn;$lsiz+=length($tokn);} $Stxt.="\n";}}
  open my $out8,'>&',STDOUT or die "Can't open  duplic8 STDOUT handle: $!";binmode $out8,':encoding(UTF-8)';print $out8 $Stxt; # crE8 local duplic8 of global
  close   $out8             or die "Can't close duplic8 STDOUT handle: $!";exit();}
my $efyl ='8.txt';my @lcnt;$lcnt[$_]=0 for(0..b10('z'));my @acnt;$acnt[$_]=0 for(0..b10('z'));my $done=0;my $t0tl=0;my $text;my $actx;my $sclc;my $gttl=0;
unless(-r         "$efyl"){$efyl=$ENV{'HOME'} . "/dox/2du/$efyl" if(exists($ENV{'HOME'}));} # try2add likely path when file not in local dir
open(my $eflh,'<',"$efyl") or die "!*EROR*! Couldn't open eight-file to read counts! $!";binmode $eflh,':encoding(UTF-8)';
while( <$eflh>){my $ldat=$_;$done=1 if(/^$/); # sets done to true when first blank line encountered
  if(/^#.*?\$d8VS\s*=\s*(['"])([0-9A-Za-z._]{8})\1\s*;/){$edVS=$2;} # this match regex seems to still need \1 && presumably ${1} would work in s/// replacement
  if  (!$done &&  $ldat  !~ /^\s*#/){ # the header lines (&& potentially l8r blocks) have pound as first non-whitespace character design8ing comments to skip
    if     (length($ldat) >= 16  ){my $pltr; # 16th column is l8st dflt 8 loc8ion, but some l8r could slide furthr
      if   (substr($ldat,    16,1) eq '8'){$pltr=substr($ldat,15,1);} # hard-coding columns as aligned interest (used to be 14 && 13, now 16 && 15)
      elsif(       $ldat =~   /^.*?(\w)8/){$pltr=$1;} # for a few lines with particularly long 8 names, the 8 wouldn't fit in the same column so srch for 1st 8
      if   (       $ldat =~   /^\s*(\w{0,15}8\w*)(\s|:)/i &&  ($folf || $gm8f || $lpsf)){my $ewrd=$1; # if mAB FindOrdrdLsFlag,thN lOdup Cntz arAy of subhashes
        push(@{$lpsd{$pltr}[        length($ewrd)]}, $ewrd) if($folf || $gm8f || $lpsf); # bild LetterPrecursorShortestsD8a for -l
        for my $wsiz (2..$mxws){if( length($ewrd) == $wsiz){$folc[$wsiz]{$ewrd}++;
            print "$G!*EROR*! duplic8 of wsiz:$wsiz for ewrd:$ewrd to remove l8r;\n"    if($folc[$wsiz]{$ewrd} > 1);}}} # sneak in Xtra duplic8ion error check
      $lcnt[b10(   $pltr )]++   if(defined($pltr) );}} # wrapng $pltr in lc() B4 b10() showz just 23(/34) countz in rvrs ordr: rnlc tzeg mdvp usbx fwkh iyo
      $text .=     $ldat;       if($fulf){my @chrz= split(//,$ldat);for my $char (@chrz){$fulc{$char}++;}}} # &&!lc: rnlc tzEm gpdv usbN LDCV URxf Gwkh PMIy SO
my    $letz  =join('',keys(%lpsd)); # these PLz won't be in order, but should be good enough for regex char-classes
close($eflh)               or die "!*EROR*! Couldn't close eight-file after reading! $!";
#if($fulf){%fulc=();for(split(//,'the of and to a in is I that it for you was with on as have but be they')){$fulc{$_}=0 if(!exists($fulc{$_}));$fulc{$_}++;}}
# temporarily try to hijack fullcharcounts above to just look within top 20 English words to compare; should extract ccnt to be like this && wc wi vary columnz
# results: Idrv:1, bfuwy:2, ns:3, ei:4, oh:5, a:6, t:8, ' ':19; # "I drive by your freeway and say 'oh a tea Space!'"
while($text=~ s/(\w)8//){$acnt[b10($1)]++;}   # counts chopping out all PLs && 8s
my @scnt = sort { $a <=> $b } (@lcnt);
for(my $sndx=$#scnt;$sndx >= 0;$sndx--){ # 2du:append bar-graphs of respective count values;
  if(($sndx > 0 && $scnt[$sndx] == $scnt[$sndx - 1]) || ($sndx == 0 && $scnt[0] == 0)){splice(@scnt,$sndx,1);}} # below2 sepR8 prnt blox for not color or with
$Stxt.=                                            sprintf("${C}8${M}Pre-cursor${Y}Letter${R}Counter$W:$G d8VS$C=%s$G\n",            d8c($d8VS));
my $efsz = length($efyl);$Stxt.=                   sprintf("$O  efyl$C=%s".' 'x (18-$efsz).$G.          " edVS$C=%s$G\n",c8fn($efyl),d8c($edVS));
$Stxt.=                                            sprintf "${C}8${M}Pre${Y}Letr$R Ct$C Full${W}Document${R}Counts\n";
$Stxt.=                                            sprintf   "$B-------- -- ------------------\n";
for(@scnt){                                                                                        $sclc=0;$actx ='';
  for my $lndx (0..$#lcnt){
    if(defined($lcnt[$lndx]) && $lcnt[$lndx] == $_){$Stxt.=   $Y           . b64($lndx) ;$t0tl+=$_;$sclc++;$actx.=' '.b8c(sprintf("%2s",b64($acnt[$lndx])));
                                                                                         $gttl+=$acnt[$lndx];}}
  my $spad=21 - 3*$sclc;$spad=0 if($spad < 0);$actx.=' ' x $spad;my $blsz=43;my $r8io=$blsz/64.0; # prEpad Nd of acnt ndxz B4 sclc flipz 4 stRtng letr colm
  $sclc   = 9 -   $sclc;$sclc=0 if($sclc < 0); # exploring gener8ing additional new bar-graphs of b8 Counts across remaining line width
  if($clmz >= 160){my  $ddig =$_   ;$actx.=' ' x (126-int($_*$r8io)); # (96-int($_/2)) wi spad=50-3*sclc abov,thN (114-int($_*$r8io)) wi spad=32-3*sclc
    while($ddig >= 64){$ddig-=   64;$actx.= $o . ('#' x  ($blsz- 1)) . "$R@";} my $mdig=$ddig % 2; # try2mk Orange 2nd blox Nd in last Red boundry
                       $ddig*=$r8io;$actx.= $R . ('#' x   $ddig    ); # odd mod rEmAndr BlO reprEsNtd betr whN Ech 64 blok fitXactly32chrz,sO just4 sOlO 1now
    if($mdig && ($blsz==32||$_==1)){$actx.= $R .  '1'               ;}} # outr colm widt tSt shud only draw bRz 4 wId termz now
  $Stxt.=sprintf ' '  x $sclc; $Stxt.=             sprintf(  "%s $actx\n",b8c(sprintf("%2s",b64($_))));}
                                                                                   my $ct0t=$G . cma($t0tl);$ct0t=~ s/(,)/$Y$1$G/g; # pre-colr comma'd t0tal
$Stxt.=                                            sprintf   "$B-------- -- ---\n";my $cttl=$M . cma($gttl);$cttl=~ s/(,)/$Y$1$M/g; # pre-colr comma'd total
$Stxt.=                                            sprintf("${C}t${M}0${C}tlz    %s %s$W :  $B(${R}b10$B)  %s  %s$W;$z",
                                                    b8colr(sprintf("%2s",b64($t0tl))),b8colr(sprintf("%2s",b64($gttl))),$ct0t,$cttl);
if($lpsf){$Stxt.="\n${W}All${R}Counts${o}Not${M}Matching${C}Words${B}List$G -$K likely from just d8-stamps, pal8 codes, or other non-word strings with 8";
  my $ptot=0;my @acor;my $slin= '';$Stxt.=" (ordered by freq then letr)$W:\n"; # PrevrowTOTalwidth, AllCountsORdered, SortedLINe
  for(0..63){if(defined($acnt[$_]) && $acnt[$_] && !exists($lpsd{b64($_)})){$slin.="$C ".b64($_)."$W:";$slin.=$r;$slin.=$R if($acnt[$_]>2);$slin.=$acnt[$_];
      push(@{$acor[$acnt[$_]]},b64($_));}}
  for(0..63){if(defined($acor[$_]) && $acor[$_]){$Stxt.=" $R";$Stxt.=$r if($_ <= 2);$Stxt.=b64($_) . "$W:$C" . join('',@{$acor[$_]});}} $Stxt.="\n$slin";
  $Stxt        .="\n${Y}Letter${M}Pre-cursor${C}Shortests${B}List$G -$K shows all entries by$M P${Y}L$K with growing word-sizes$W:\n\n";for(@scnt){
    last if($_ >= 108 && $pg1f); # for single -p page try to skip out after t && z 102 before c && l && n 131
    for     my $lndx (0..$#lcnt){if(defined($lcnt[$lndx]) && $_ ==   $lcnt[    $lndx]){my $letr=b64($lndx);
        my                                                                 $rtot=2 ;   my $ltot=     0    ;$Stxt.="$Y$letr$R:"; # hRdcOded prEnwlInz abov
        for my $wsiz (2..$mxws ){if(exists ($lpsd{$letr}) && defined($lpsd{$letr}       ) && scalar(@{$lpsd{$letr}       }) &&
                                                             defined($lpsd{$letr}[$wsiz]) && scalar(@{$lpsd{$letr}[$wsiz]})){
            if    ($rtot + length($wsiz                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
            $rtot        +=length($wsiz                     ) + 1          ;$ltot+=          scalar(@{$lpsd{$letr}[$wsiz]});$Stxt.="$B$wsiz$W:$z";
            for my $wndx (0 .. $#{$lpsd{$letr}[$wsiz]}){
              if  ($rtot + length($lpsd{$letr}[$wsiz][$wndx]) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
              $rtot      +=length($lpsd{$letr}[$wsiz][$wndx]) + 1 ;  $lpsd{$letr}[$wsiz][$wndx]=~ s/(8)(ion)$/$1$C$2$z/;     # colr most comon ion sufx
                                                                     $lpsd{$letr}[$wsiz][$wndx]=~ s/($letr)(8)/$o$1$G$2$z/g; # colr 8PLz
              $Stxt      .=       $lpsd{$letr}[$wsiz][$wndx]  .' ';}}}
        if        ($rtot + length($ltot                     ) + 1 >  $clmz){$ptot =$rtot;$Stxt.="\n";$rtot=0;}
        $rtot            +=length($ltot                     ) + 1 ;                      $Stxt.=  "$M$ltot ";
        if($ptot + $rtot <= $clmz){$Stxt=~ s/(.*)\n/$1/s;$ptot+=$rtot;}else{$ptot=$rtot;}$Stxt.="\n";$rtot=0;}}}} $Stxt=~ s/\n$//;
if($folf){$Stxt.="\n${Y}Word${R}Sort${C}By${B}Size$G -$K up to current maximum$M $mxws$K or one$p page$K if given$p -p$W:\n";my $maxs=$mxws;$maxs= 9 if($pg1f);
  for   my $wsiz (2..$maxs ){my @folk=sort(keys(%{$folc[$wsiz]}));$Stxt.= $B.sprintf("%${wsiz}d ",scalar(@folk));my $rtot=$wsiz+1;
                                                                  $Stxt.="$R $wsiz"        unless(scalar(@folk));
    for my $fndx (0..$#folk){my $foln=$folk[$fndx];if($rtot + length($foln) + 1 >  $clmz){$Stxt.="\n";$rtot=0  ;} $rtot+=length($foln)+1;
                                $foln=~ s/(8)(ion)$/$1$C$2/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;$Stxt.="$z$foln ";} $Stxt=~ s/ $/\n/;}} # $Stxt.="$G @folk\n";
# HCOL8fol:had 15 \w8, 33 3-letrz, && 60 4-letrz (108 t0tl, mAB 12 of wich alredy Xist in bin/ stably or canB tmp DmOtd 2mk nxt nw 96 Dsciptnz pAg lIk sumb),
#   98 5letr wordz (2past own nw 3rd 96 sumb pAg), 162 6z, 200 7z, 132 8z, 110 9z, 76 10z, 63 11z, 54 12z, 37 13z, 23 14z, 3 15z, 6 16z, 1 17z, 0 18z, 2 19z ;
# HCQL3VIP:sOfR of just 2z 3z 4z,nEd2cut 12 2fit nXt 96 sumb pAg,b8 c8 d8 g8 w8 ckm8 pal8 upd8 alredy bin is 8,DlA sumb4 N8 DN8 NfN8 SSN8 as obtuse;lFt9,32,55
# 15   N8   b8   c8   d8   f8   g8   h8   k8   l8   m8   p8   r8   s8   w8   y8
# 33  DN8 aV8 ab8 al8 aw8 b8a bl8 cr8 el8 f8h f8l fL8 fr8 gM8 gr8 iD8 ir8 mL8 oP8 or8 pN8 pl8 pr8 rN8 sN8 sk8 sl8 sp8 st8 sw8 tr8 ur8 vL8
# 60 NfN8 SSN8 abl8 aer8 agn8 aur8 bel8 ber8 bin8 bor8 bov8 ckm8 col8 crE8 crN8 cur8 deV8 deb8 dil8 don8 equ8 est8 exP8 fix8 gyr8 inm8 inn8 ion8 kin8 l8nt
#    leg8 lig8 loc8 lor8 lun8 lux8 meD8 mor8 mut8 neg8 not8 obV8 obl8 orn8 pal8 pir8 pup8 r8io raD8 reb8 rel8 rot8 s8E8 sed8 stL8 str8 tan8 upd8 vac8 zon8
if($gm8f){$Stxt.="${W}Gener8 gM8ria primes for names by$B 3$W segments (${Y}PreLetters$W,$G Suffixes$W,$C Prefixes$W)...\n$G"; my $eqfz='';my $eqct=0;
  my %w2pm;my %wh2p;my @wpls;my %kvs8;my %pl8z;my %sufz;my %prez;my %pl8s;my %sufs;my %pres;my %allc;my %allp;my @plrl;my %ppbs;my $bbct=0;my $colc=0;
  my $mxpa=1;#$mxws=19;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]})); # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){$pl8z{$2 }=0 unless(exists($pl8z{$2 }));$pl8z{$2 }++;
        if(defined($1) && length($1)     ){$prez{$1 }=0 unless(exists($prez{$1 }));$prez{$1 }++;}
        if(defined($3) && length($3)     ){$sufz{$3 }=0 unless(exists($sufz{$3 }));$sufz{$3 }++;}
        else                              {$sufz{'_'}=0 unless(exists($sufz{'_'}));$sufz{'_'}++;}}}}
  for   my $kyst (sort(keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){$Stxt.=sprintf("${Y}plct$W:%s$M%4d$Y pl8z$W:$o%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++)                             ;}} %kvs8=();#$Stxt.="\n";
  for   my $kyst (sort(keys(%sufz))){push(@{$kvs8{$sufz{$kyst}}},$kyst);} # nice that there are exactly 8 count categories of sufz, 14 PLz, 6 prez (28 totl)
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){if(@{$kvs8{$kvct}} == 1 && $kvs8{$kvct}[0] eq  'ion'){
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:${B}ion\n",b8c(sprintf("%3s",b64($kvct))),$kvct);}else{
      $Stxt                                          .=sprintf("${G}sfct$W:%s$M%4d$G sufz$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,
    join(' ',     sort(@{$kvs8{$kvct}})));}
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}} %kvs8=();#$Stxt.="\n"; # try to reuse earlier segments
  for   my $kyst (sort(keys(%prez))){push(@{$kvs8{$prez{$kyst}}},$kyst);}
  for   my $kvct (sort {$b <=> $a} keys(%kvs8)){my $s8ls='';my $rtot=18; # bild up an rtot to pump newlinez into s8ls before appending wider than clmz
    for my $ssvl (sort(@{$kvs8{$kvct}})){if($rtot + length($ssvl) + 1 >= $clmz){$s8ls.="\n";$rtot=0;} $rtot+=length($ssvl) + 1;
      $s8ls.=S(substr('YCMGRBop',b10(substr($ssvl,0,1)) % 8,1)) . "$ssvl ";} $s8ls=~ s/ $//;
    $Stxt.=sprintf("${C}prct$W:%s$M%4d$C prez$W:$z%s\n"   ,b8c(sprintf("%3s",b64($kvct))),$kvct,$s8ls);
    for my $sprt (sort(@{$kvs8{$kvct}})){$w2pm{$sprt}=prim($mxpa++) unless(exists($w2pm{$sprt}));}}                # try to keep reusing earlier segments
  $Stxt  .="${W}gM8ria primes with$B 3$W sepR8 sections:$Y PL$W,$G suffixes$W,$C prefixes$W but with special case 1st$G suffixes$W:$z _$W &&$B ion$W for ";
  $Stxt  .="smaller highest nums...\n";
  %pl8s=();%sufs=();%pres=();%w2pm=();%wh2p=();%kvs8=();@wpls=();%allc=();%allp=();$bbct=$colc=0;$mxpa=1;
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        push(@{$ppbs{$pltr}},$pfix) if(length($pfix));}}}
  for   my $kyst (sort(            keys(%pl8z))){push(@{$kvs8{$pl8z{$kyst}}},$kyst);}          $allp{prim($mxpa)}='_'  ;$sufs{'_'  }=prim($mxpa++);
                                                                                               $allp{prim($mxpa)}='ion';$sufs{'ion'}=prim($mxpa++);
  for   my $kvct (sort {$b <=> $a} keys(%kvs8) ){for my $sprt  ( sort(@{$kvs8{$kvct}})       ){$allp{prim($mxpa)}=$sprt;$pl8s{$sprt}=prim($mxpa++);
                                                                                                                unshift(@plrl,$sprt)              ; }}
  for   my $pdig (0..3                         ){                                              $allp{prim($mxpa++)}="$pdig";} # pad4digitz2grow curNt stably?
  for   my $kyst (sort {length($a) <=> length($b)} sort(keys(%sufz))){if($kyst !~ /^(_|ion)$/){$allp{prim($mxpa)}=$kyst;$sufs{$kyst}=prim($mxpa++); }}
  for   my $pdig (4..7                         ){                                              $allp{prim($mxpa++)}="$pdig";} # digz wil nEd2ch if evrin spLng
  for   my $pltr (@plrl                        ){for my $sprt  (      @{$ppbs{$pltr}}        ){unless(           exists($pres{$sprt})){
                                                                                               $allp{prim($mxpa)}=$sprt;$pres{$sprt}=prim($mxpa++);}}}
  $Stxt  .="${z}pres${C}By${B}Size$W:$z";my $rtot=11;for my $sprt (sort {length($a) <=> length($b)} sort(keys(%pres))){
    if($rtot + length($sprt) + 1 >= $clmz){ $Stxt.="\n";$rtot=0;}
    $rtot    +=length($sprt) + 1;           $Stxt.= S(substr('YCMGRBop', length($sprt) % 8,1)) . "$sprt ";} # colr sequ by size
  for   my $wsiz (2..$mxws ){my @folk=sort(keys(%{$folc[$wsiz]}));
    for my $fndx (0..$#folk){my $curw=$folk[$fndx];
      if($curw=~ /^(\w*?)([A-Z])8(\w*)$/i){my $pltr=$2;my $sfix='_';$sfix=$3 if(defined($3) && length($3));my $pfix='';$pfix=$1 if(defined($1) && length($1));
        my $cmps=$pl8s{$pltr};$cmps*=$sufs{$sfix}   if($sfix ne '_' || $pfix);$cmps*=$pres{$pfix} if($pfix);$wh2p{$cmps}=$curw;$w2pm{$curw}=$cmps;
        $bbct++ if(length(b64($cmps)) >  length($curw)); # count b64 versions of composite numbers that are longer than (or same as) 8-word they refer to
       #$Stxt.=sprintf("$z%19s%s$C%2d",$curw,b8c(sprintf("%5s",b64($cmps))),$bbct);if(++$colc==6){$colc=0;$Stxt.="\n";}
      }}} $colc=0;$eqct=0;$eqfz='';$Stxt=~ s/\n?$/\n/; # now 0/1238 have longer b64 numrep than referred 8word
  for   my $kyct (sort {$a <=> $b} keys(%wh2p)){my $vwrd=sprintf("%20s",$wh2p{$kyct});for my $nndx (1..4){if(substr($vwrd,-1*$nndx,1) eq '8'){my $sfsz=5-$nndx;
        $vwrd=~ s/^(\s{$sfsz})(.+)$/$2$1/;last;}} # right-align the 8 column for almost all words (except when suffix is longer than 4 chars)
    $vwrd    =~ s/^(\s*dil88ion\s*)(\s)$/$2$1/;   # special-case alignment correction to 1 extra space for '88ion'
    $vwrd    =~ s/([A-Z])(8)/$Y$1$G$2$z/gi;my $tkct=$kyct;my $twrd='';my $tpmz='';my $sfxf=0;for my $tprm (sort {$a <=> $b} keys(%allp)){
      if   (($tkct % $tprm) == 0              ){$tpmz.="$tprm,";$tkct/=$tprm;  # mA nEd2filtr out 0..7 pad digitz,thN add special sufx ckz4 _|ion 1st, ...
        if   (length($twrd) == 0              ){                               #   ...thN get reqd PL,thN mAB othr sufx,fInalE prEpNd any rEmAning prefix
          if ( $allp{$tprm} =~ /^(_|ion)$/    ){$twrd = $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
          else                                 {$twrd ="$allp{$tprm}8"     ;}} # stil quite simpl3sections always in ordr (Xcept special _|ion sufxz)
        elsif(length($twrd) == 2 && $sfxf == 0){$twrd.= $allp{$tprm} if($allp{$tprm} ne '_');$sfxf=1;}
        elsif($twrd =~ /^(ion)$/ && $sfxf == 1){$twrd ="$allp{$tprm}8$twrd";}  # 27,676,799 ostent8ious last (wi 8 pad digitz,4btwn sectnz 4 mor stabl growth)
        else                                   {$twrd ="$allp{$tprm}$twrd" ;}}}
    $tpmz=~ s/,$//;my $trmc='!';if($wh2p{$kyct} eq $twrd){$trmc=';';$eqct++;}else{$eqfz.="$G$wh2p{$kyct}$W:$B$twrd$W, ";} $vwrd=~ s/(ion\s*)$/$B$1/; # tryBlu
    if($pg1f){last if($kyct> 103754);$Stxt.=sprintf("%s$z%s$W%s",b8c(sprintf("%4s",b64($kyct))),$vwrd,$trmc);if(++$colc == 6){$colc=0;$Stxt.="\n";}}
    else     {    $Stxt.=sprintf("$M%11s %s$z %s$W%s",cma($kyct),b8c(sprintf("%5s",b64($kyct))),$vwrd,$trmc);if(++$colc == 4){$colc=0;$Stxt.="\n";}}
  } $eqfz=~ s/, $//;  $Stxt=~ s/\n?$/$W\n/;$colc=0;#Stxt.="eqct:$eqct totl:" . scalar(keys(%wh2p)) . " eqfz:$eqfz"; # rebild Cmz2alreDB fIn4 100% of cur8wrdz
  open my $log8,'>',"$ENV{'HOME'}/.log/8p.ls" or die "Can't open  log 8primes.list file handle: $!";binmode $log8,':encoding(UTF-8)';
  print   $log8 "# $d8VS:~/.log/8p.ls gener8d by 8plc with 8.txt edVS:$edVS to save sepR8 reference to 8-word prime maps by PipStuart <Pip\@CPAN.Org>;\n";
  for  my $prmk (sort {$a <=> $b} keys(%allp)){print $log8 sprintf("%-4d %-15s ",$prmk,$allp{$prmk});if(++$colc == 7){$colc=0;print $log8 "\n";}}
  close   $log8                               or die "Can't close log 8primes.list file handle: $!"; # try2wrItout prImz list for l8r sepR8 rFrNc
          delete($folc[2]{ 'N8'});delete($folc[2]{  'b8'});delete($folc[2]{  'c8'});delete($folc[2]{  'd8'});delete($folc[2]{  'g8'});delete($folc[2]{  'w8'});
          delete($folc[3]{'DN8'});delete($folc[4]{'NfN8'});delete($folc[4]{'SSN8'});delete($folc[4]{'ckm8'});delete($folc[4]{'pal8'});delete($folc[4]{'upd8'});
          delete($folc[5]{'m8rix'});delete($folc[5]{'coll8'}); # not sure if coll8 is best 2nd to remove of 5z, but m8rix is probably good enough as p8:m8rx
  $mxws=  5 if($pg1f);
  $Stxt=~ s/\n?$/\n/;for my $wsiz (2..$mxws){my @folk=sort(keys(%{$folc[$wsiz]}));my @fola=();$Stxt.=$G; # prEstrip12cutz abov lEvng justnXt Xctly96 2fOcus on
    my $stcz=int($clmz / 6); # normal initial alignments are 5 characters plus space, which should normally fit original 26 word columns within 160 char colmz
    if($wsiz == 2){$Stxt.="${W}Only 2z fit with preceding lines of b8 (2 4095), products only also fit 3z, otherz should fit sums && averages (B4nw2ad).\n$B";
      for my $fndx (0..$#folk){my $b10w=b10($folk[$fndx]);$Stxt.=sprintf(" %5d"      ,$b10w);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$M";
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$C";}
    if($wsiz == 3){                                                                                                                  $Stxt.=   $M ;
      for my $fndx (0..$#folk){my $prod=1;$prod*=b10($_) for(split(//,$folk[$fndx]));
                                                          $Stxt.=sprintf(" %5d"      ,$prod);$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n"  ;}
    if($wsiz <= 5){                                                                                                                  $Stxt.=   $C ;
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %5d"        ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $fstr =sprintf(" %2.2f"      ,$fola[$fndx]);$fstr=~ s/(\.?0+)$/$r$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%5s" ,b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz aligned with other numb repz
                                                                              $Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){my $foln =sprintf(" %5s"        ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g; # valid PLz
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $stcz);} $Stxt.="\n";}
    elsif(scalar(@folk)){      my $wrdw=int($clmz / ($wsiz+1) );$Stxt.=$C; # skip over empty 18z
      for my $fndx (0..$#folk){my $sumc=0;$sumc+=b10($_) for(split(//,$folk[$fndx]));$fola[$fndx]=$sumc*1.0/$wsiz;
                                  $Stxt.=sprintf(" %${wsiz}s"  ,$sumc       );$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$R";
      for my $fndx (0..$#folk){my $frsz =$wsiz-3; # mAB special cAs 8 2fit just %2.3f or mk trail zer0z dRk red nstd?
                               my $fstr =sprintf(" %2.${frsz}f",$fola[$fndx]);$fstr=~ s/(\.?0+)$/$k$1$R/;
                                  $Stxt.=                       $fstr        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){   $Stxt.=' '.b8c(sprintf("%${wsiz}s",b64($w2pm{$folk[$fndx]}))); # try2insrt composite prime mapz
                                                                              $Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n$z";
      for my $fndx (0..$#folk){my $foln =sprintf(" %${wsiz}s"  ,$folk[$fndx]);$foln=~ s/(8)(ion)$/$1$B$2$z/;$foln=~ s/([$letz])(8)/$Y$1$G$2$z/g;
                                  $Stxt.=                       $foln        ;$Stxt.="\n" unless(($fndx+1) % $wrdw || $fndx==$#folk);} $Stxt.="\n";}
# try2loop avrgz abov nstd but mA nEd special wrapz dn from 26 B4 6 to 6:22, 7:20, 8:17, ... shud B formUla or Dtectabl
# old notez4wsiz 2: this is probably more useful mean average summariez && think of prime factorz or othr wayz to represent mostly unique partz
#                5: try to cut 2 (or 6 if adding 4 N8 varE8ionz bakin) to get 5z dn2 3rd rel8ively clean concise set of 96 to make another sumb page out of
  } $Stxt.="${C}cutz$W:$Y 2$W:${G}N8 $o(${K}b8 c8 d8 g8 w8$o)$Y  3$W:${G}DN8$Y  4$W:${G}NfN8 SSN8 $o(${K}ckm8 pal8 upd8$o)$Y  5$W:${G}m8rix coll8$Y";
    $Stxt.="$Y  6$W:${G}?$Y  7$W:${G}?$Y ...\n"; # hopefully above -g will align a b10 line over b64 lines
  # try new small set of sequential prime number alloc8ions && then multiply recurring subset primes then try to refactor && reconstruct from gr8st down
  $folc[2]{ 'N8'}=$folc[2]{  'b8'}=$folc[2]{  'c8'}=$folc[2]{  'd8'}=$folc[2]{  'g8'}=$folc[2]{  'w8'}=1;
  $folc[3]{'DN8'}=$folc[4]{'NfN8'}=$folc[4]{'SSN8'}=$folc[4]{'ckm8'}=$folc[4]{'pal8'}=$folc[4]{'upd8'}=1;
  $folc[5]{'m8rix'}=$folc[5]{'coll8'}=1; # need to try to put cuts back in so PL counts can match again
}   # maybe multiplying && factoring primes as essentially bit-flags requiring escal8ing order to build words to according to growing wsiz ordr is inefficient
    #   && still indirect, but mAB less useful than srchng whole word-set entirely to build all at once deliber8ly right-to-left wi prioritized substringz?
if($fulf){$Stxt=~ s/\n?$/\n/;my %cvlz=reverse(%fulc);my @ccnt= sort { $a <=> $b } keys(%cvlz);my $jus8=0;my $sumn=0; # 2colmzof fulcntz fitznIc undr50lInz sOfR
  for     my $cndx (0..$#ccnt){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    for   my $char (sort(keys(%fulc))){ # this now is intended to be just a single linear column which duplic8z the content of the orig 2-columnz below
      if    ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
        $sumn      +=  $coun                    if($char=~ /^[0-79]$/       ); # special sum of Non-8 digits to compare at end
        $jus8       =  $coun                    if($char=~ /^8$/            ); # special just       8        to compare at end
        $w82o      .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
    } # $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,$z    %4d$B;\n",cma($coun),b8colr(sprintf("%4s",b64($coun))),$cndx); 
  }   # $Stxt.="\n"; # just disabling now redundant double-long single column full counts list output, but still keeping the 8 vs. other digit counts
  for     my $cndx (0..int($#ccnt/2 )){my $coun=$ccnt[$cndx];my $pcnt=0;my $w82o=''; # FullFile CharCounts abov as Values (or values(%fulc) nEdzUniq)
    if($cndx < int($#ccnt/2)+1){ # +1 was abov with @ccnt nstd of $#ccnt && originally had the +1 inside the int() call here
      for my $char (sort(keys(%fulc))){ # then above CharCouniNDeX loops just unique counts && (was Probably) PrintCouNT before Wait to Output8
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # probably only newline shouldn't be printed normally to ruin formatting
      } $Stxt.=' ' x (32-$pcnt)."$G$w82o$B:$M".sprintf("%7s$B: %s$W,",cma($coun),b8colr(sprintf("%4s",b64($coun))));
    } $coun=$ccnt[int($#ccnt/2)+$cndx+1];                       $pcnt=0;   $w82o=''; # restore conditions for always 2nd column for now (ad optn l8r)
    if(defined($coun)){ # odd number of chars may leave last invalid coun so check   # abov hook used to be ?1:0 but now testing whether necessary
      for my $char (sort(keys(%fulc))){ # no longer trying to sum non-8 digitz during 2-column printing down here, doing it once during the single column abov
        if  ($coun ==    $fulc{$char}){ $pcnt++ if($char=~ /^(印|注|米|\n)$/); # special count for only double-wide characters
          $w82o    .= ($char eq "\n") ? '\n' : $char;$pcnt++;} # belo was once trying some random colrz with: ,S(substr($cmap{'d8bo'},b64(int(rand(8))),1)));
      } $Stxt.=sprintf((' ' x ( 8-$pcnt))."$C$w82o$B:$M".sprintf("%7s$B: %s$W,\n",cma($coun),b8colr(sprintf("%4s",b64($coun)))));
    } } $Stxt.=sprintf("$C  Sum of$B: ${G}0$W..${G}7$W,${G}9$B: $M%s$o      dif$Y:$B%7s$W;$z",cma($sumn),cma($jus8-$sumn));} $Stxt=sS($Stxt) unless($clrf);
open my $out8,'>&',STDOUT or die "Can't open  duplic8 STDOUT handle: $!";binmode $out8,':encoding(UTF-8)';print $out8 $Stxt; # crE8 local duplic8 of global
close   $out8             or die "Can't close duplic8 STDOUT handle: $!";
